#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008080
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Part*
Week #1
\end_layout

\begin_layout Subsection

\color blue
Define following terms and concepts shortly:
\end_layout

\begin_layout Enumerate
Network bandwidth
\end_layout

\begin_layout Enumerate
Network throughput
\end_layout

\begin_layout Enumerate
Packet loss and jitter
\end_layout

\begin_layout Enumerate
bps vs Bps
\end_layout

\begin_layout Enumerate
Protocol payload
\end_layout

\begin_layout Enumerate
Protocol overhead (especially for resource-contrained IoT purposes)
\end_layout

\begin_layout Enumerate
Spanning Tree Protocol
\end_layout

\begin_layout Enumerate
Collision domain
\end_layout

\begin_layout Enumerate
Broadcast domain
\end_layout

\begin_layout Enumerate
SOHO network
\end_layout

\begin_layout Enumerate
MAC (physical) address
\end_layout

\begin_layout Enumerate
Physical layer protocol data unit (PDU)
\end_layout

\begin_layout Enumerate
MAC layer protocol data unit (PDU)
\end_layout

\begin_layout Enumerate
Half-duplex vs Full-duplex
\end_layout

\begin_layout Enumerate
Ethernet auto-negotiation
\end_layout

\begin_layout Enumerate
Hidden node problem (wireless)
\end_layout

\begin_layout Enumerate
Networking physical vs logical topology
\end_layout

\begin_layout Enumerate
TIA/EIA-568 and ISO/IEC_11801
\end_layout

\begin_layout Enumerate
Ethernet cabling categories.
 For example,
 CAT 6
\end_layout

\begin_layout Enumerate
8P8C (RJ45)
\end_layout

\begin_layout Enumerate
Wifi AD HOC
\end_layout

\begin_layout Enumerate
IEEE 802.11ac,
 802.11ax,
 802.11be
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate
The definition of “
\series bold
\color brown
Bandwidth
\series default
\color inherit
” in the computing domain refers to the rate of data over time.
 Data is usually measured in bits,
 the time unit in seconds,
 and it’s often abbreviated as “bps”.
 This term is also used in lower-layer protocols,
 like the PHY layer in Wi-Fi,
 where bandwidth is measured in hertz (Hz),
 not in bps,
 but the wider the channel in Hz,
 the more bps can be transmitted.
 In Wi-Fi,
 it basically represents the channel width.
 Bandwidth refers to the maximum theoretical capacity of a channel to transmit data,
 it’s a property of the medium or communication channel,
 not the actual speed.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Throughput
\series default
\color inherit
,
 like bandwidth,
 also represents a rate of data over time,
 but unlike bandwidth where bps means the total theoretical capacity of the channel throughput measures the amount of bits delivered from source A to source B.
 In fact a data transmission can encounter different obstacles on the way,
 which can lead to packet loss or delays,
 that is why measuring throughput is critical in networking and signal processing.
 Data can be measured not only in bits,
 but also in packets or frames (blocks containing a fixed number of bits).
 
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Packet loss
\series default
\color inherit
 could be represented by formula:
 
\color red
PLR = (1 - (received frames) / (total frames transmitted))
\color inherit
 this shows the ratio of lost packets to total sent packets.
 The higher the result of this formula,
 the worse the channel quality.
 
\color brown
Jitter
\color inherit
 is a complex measurement and it can be calculated in different ways.
 For example,
 there are Random Jitter (RJ),
 Deterministic Jitter (DJ),
 and Total Jitter (TJ).
 Basically,
 jitter shows the variation in the packet delivery time in other words,
 how much the interval between packet arrivals changes over time the higher is a jitter value the less stable and predictable is a signal.
\end_layout

\begin_layout Enumerate

\series bold
\begin_inset Quotes eld
\end_inset


\color brown
bps
\series default
\color inherit

\begin_inset Quotes erd
\end_inset

 is an abbreviation for bits per second,
 while 
\begin_inset Quotes eld
\end_inset


\color brown
Bps
\color inherit

\begin_inset Quotes erd
\end_inset

 is bytes per second.
 
\color red
1 byte = 8 bits
\color inherit
.
 “Bps” is used in higher-layer protocols because data sizes are usually measured in bytes rather than bits.
 
\begin_inset Quotes eld
\end_inset

bps
\begin_inset Quotes erd
\end_inset

 is more useful in lower-layer protocols such as MAC or PHY.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Protocol payload
\color inherit
.

\series default
 Protocol in domain of computing is a set of rules which defines the way how to deliver and extract the message,
 without which it would be a random bit stream.
 
\color brown
Payload
\color inherit
 is an actual message,
 for which protocol is applied.
 
\series bold
\color brown
Message
\series default
\color inherit
 is a meaningful expression with well defined bounds (it has finite size) for example:
 
\family typewriter
\color darkgray

\begin_inset Quotes eld
\end_inset

I want to stop writing right now and go take some beer
\begin_inset Quotes erd
\end_inset


\family default
\color inherit
.
 
\color brown
Protocol payload
\color inherit
 is a message.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Protocol overhead
\series default
\color inherit
 is the extra cost,
 which can be represented as time,
 extra bits,
 and processing logic needed for delivering data from source to destination.
 For example,
 some protocol header bits must be sent with a message (payload) to ensure that the receiver can extract the message.
 It also could be some logic like a handshake in TCP to establish a connection between RX (receiver) and TX (transmitter).
 In the end,
 all of these things are time-consuming,
 that’s why they are called overheads.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Spanning Tree Protocol (STP)
\color inherit
,

\series default
 defined in IEEE 802.1D,
 is used to prevent loops in switched networks.
 Switches communicate with each other by sending BPDU (Bridge Protocol Data Units) every 2 seconds.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\shape italic
\begin_inset Quotes eld
\end_inset

I Think That I Shall Never See
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Graph More Lovely Than A Tree.
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Tree Whose Crucial Property
\end_layout

\begin_layout Standard

\family sans
\shape italic
Is Loop-free Connectivity.
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Tree That Must Be Sure To Span
\end_layout

\begin_layout Standard

\family sans
\shape italic
So Packets Can Reach Every LAN.
\end_layout

\begin_layout Standard

\family sans
\shape italic
First,
 The Root Must Be Selected.
\end_layout

\begin_layout Standard

\family sans
\shape italic
By ID,
 It Is Elected.
\end_layout

\begin_layout Standard

\family sans
\shape italic
Least Cost Paths From Root Are Traced.
\end_layout

\begin_layout Standard

\family sans
\shape italic
In The Tree,
 These Paths Are Placed.
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Mesh Is Made By Folks Like Me,
\end_layout

\begin_layout Standard

\family sans
\shape italic
Then Bridges Find A Spanning Tree.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
At the start,
 all switches consider themselves as the root bridge and send BPDU messages containing their Bridge ID to neighboring switches.
 Each switch compares its own Bridge ID with the neighbor’s and forwards the smallest one further.
 After several exchanges,
 all switches know the Root Bridge,
 the switch with the lowest Bridge ID.
 Next,
 each switch calculates the shortest path to the Root Bridge using the path cost defined in 802.1D.
 If a switch has multiple paths,
 the shortest one is kept as the designated port,
 and the longer path is blocked.
 As a result,
 STP creates a loop-free spanning tree,
 ensuring that packets can reach every LAN segment while avoiding broadcast storms.
\end_layout

\end_deeper
\begin_layout Enumerate
A 
\series bold
\color brown
collision domain
\series default
\color inherit
 is a segment of a network space where a signal is traveling.
 To communicate,
 clients sometimes use the same route for example,
 the same frequency if we talk about Wi-Fi.
 When two clients try to send data at the same time on the same channel,
 their signals interfere and collide it will lead to packet loss.
 After a collision,
 the data must be retransmitted,
 which causes delays and reduces network performance.
\end_layout

\begin_layout Enumerate
A 
\series bold
\color brown
broadcast domain
\series default
\color inherit
 can be described as a segment of a network.If I send a frame on Layer 2 with the destination address FF:FF:FF:FF:FF:FF,
 it means “send this to all members of my subnet where I am located.”If the router is configured to combine several physical subnets into one logical subnet,
 then all of them become part of the same broadcast domain,
 even if they are physically separated.However,
 the actual boundary of such a broadcast domain will always end at the router,
 which separates this domain from the rest of the internet.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SOHO network 
\series default
\color inherit
(Small Office / Home Office) is not an official networking term,
 meaning it is not defined in any standards like IEEE 802.11.SOHO is used to describe a networking scenario,
 where several clients are connected through the same router or the same physical cable.In most cases,
 all clients are members of a single subnet,
 sharing the same LAN and belonging to the same broadcast domain.However,
 a SOHO network can also contain multiple broadcast domains for example,
 one subnet can be used for guests,
 another for IoT devices,
 and another for regular users.This separation is usually done using VLANs configured on the same router.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
MAC (physical)
\series default
\color inherit
 address is a unique number that every device with a network interface has,
 for example Wi\SpecialChar nobreakdash
Fi or Ethernet.
 It is usually 48 bits and written as hexadecimal pairs,
 for example AA:BB:CC:DD:EE:FF.
 MAC addresses are used on the Data Link Layer (Layer 2) so that devices can find each other inside the same network.
 When one device sends a frame to another,
 it puts its own MAC as the source and the MAC of the receiver as the destination.
 Without MAC addresses,
 sending data would be a lot more complicated,
 because devices would have to “ask” everyone in the network if the packet is for them.With MAC,
 it’s much easier —
 switches and Wi\SpecialChar nobreakdash
Fi routers know exactly where to deliver the frame.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Physical layer protocol 
\series default
\color inherit
data unit (PDU) is a bit.
 Generally,
 the physical layer does not have any high-level logic except for math and physics,
 where bits are turned into signals.
 In Wi-Fi these are radio waves,
 in Ethernet they are electrical signals,
 and in optical fiber they are light flashes.
 The exact instructions on how to modulate the signal come from Layer 2.
 The physical layer is usually optimized more by mathematicians and physicists than by programmers,
 but it's best when all three skills are combined in one person.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
MAC layer protocol data unit (PDU)
\series default
\color inherit
 is called a frame.
 Before sending data to the physical layer,
 L2 takes the IP packet from L3,
 adds the source and destination MAC addresses,
 and then the logic depends on the type of network.
 In modern Ethernet,
 which works in full-duplex,
 there’s no need for collision detection,
 so MAC mostly just adds the addresses and passes the frame down to the PHY layer.
 In Wi\SpecialChar nobreakdash
Fi,
 the MAC layer is a lot smarter:
 it has to analyze the channel,
 choose the right modulation for PHY,
 run algorithms to avoid collisions (CSMA/CA with random backoff),
 and only after all of this it sends the frame to L1 for transmission.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Half-duplex vs Full-duplex
\series default
\color inherit
.
 Half-duplex means a device can either transmit or receive,
 but not at the same time.
 Full-duplex means sending and receiving simultaneously.In modern Ethernet full-duplex is implemented on the physical level:
 the cable has separate pairs of wires for transmitting and receiving,
 so data flows both ways at once without collisions.
 In Wi-Fi,
 on the other hand,
 communication is half-duplex.
 A station cannot transmit and receive at the same time because its own signal would interfere with the receiver.
 Wi-Fi uses channel access algorithms and sometimes separates uplink and downlink subcarriers,
 but simultaneous full-duplex transmission is generally not used in current standards.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Ethernet auto-negotiation
\series default
\color inherit
 is a synchronization mechanism that allows two devices connected by an Ethernet cable automatically choose the best way to communicate.
 When devices are connected via cable,
 both start sending special signals called FLP (Fast Link Pulses),
 these signals contain information about what technologies each device has,
 like the supported speeds,
 duplex modes,
 and whether they support flow control.
 After exchanging this information,
 the devices compare their capabilities and pick the highest performance mode they both support.
 First,
 they choose the maximum possible speed,
 then they check the duplex mode:
 if both sides support full-duplex,
 they use it;
 otherwise,
 they fall back to half-duplex.
 Finally,
 they decide if flow control will be used which is a feature that helps to avoid packet loss when one side is slower than the other by 
\begin_inset Quotes eld
\end_inset

holding
\begin_inset Quotes erd
\end_inset

 data transmission.
 If auto-negotiation is disabled on one device but enabled on the other,
 the devices may choose different duplex modes,
 which leads to collisions,
 retransmissions,
 and lower performance.
 That’s why in most modern networks,
 auto-negotiation is enabled on both ends.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Hidden node problem
\series default
\color inherit
 (wireless) can occur when STAs (clients) are located far from each other but use the same AP (access point) between them.
 This is a MAC layer problem.
 In Wi\SpecialChar nobreakdash
Fi,
 all STAs share the same medium.
 When one STA sends data,
 it assumes the channel is free,
 but another STA may do the same,
 causing collisions and packet loss.
 To avoid this,
 the IEEE 802.11 standard includes the RTS/CTS (Request to Send / Clear to Send) mechanism:
 the device first sends RTS to the AP,
 and if the AP replies with CTS,
 other devices stay silent during the transmission.
 RTS/CTS is not always enabled because it adds overhead and is usually used when many clients are connected to the same AP.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Networking physical vs logical topology.

\series default
\color inherit
 
\series bold
\color brown
Physical topology
\series default
\color inherit
 is based on real devices like routers,
 switches,
 and bridges (older tech),
 linked via radio channels or physical cables.
 A simple example is a PC or several PCs connected to a switch via cables,
 and the switch connected to a router.
 Physical topology is a core part of networking,
 like a skeleton.
 There are several common types of physical topology,
 and some of them are outdated today:
 Star,
 Mesh,
 Ring,
 and Bus.
\end_layout

\begin_deeper
\begin_layout Itemize
Star topology is most common type today.
 Multiple devices are connected to the same central switch or hub.
 If one cable fails,
 the rest of the network keeps working.
 But if the central device fails,
 the entire network goes down.
\end_layout

\begin_layout Itemize
Mesh topology is modern and very reliable.
 Each device connects to several others,
 so there are multiple paths for data.
 If one link fails,
 traffic can be rerouted automatically.
 Full mesh (each device connected to all others) is rare because it’s expensive,
 so partial mesh is used more often.
 This idea is also used in Wi-Fi mesh networks to cover a large area without dead zones.
\end_layout

\begin_layout Itemize
Ring topology is when devices are connected in a circle,
 and data goes step by step through each node until it reaches the destination.
 Today,
 ring topologies are rare and mostly remain in some industrial or optical systems.
\end_layout

\begin_layout Itemize
Bus topology is one of the earliest types,
 where all devices share a single cable.
 Simple but depricated,
 replaced by switches and modern Ethernet.
\end_layout

\begin_layout Standard

\series bold
\color brown
Logical topology
\series default
\color inherit
 describes how data actually flows inside the network,
 regardless of how devices are physically connected.
 Even if multiple PCs are connected to the same physical switch (star topology),
 logically they can belong to different subnets or VLANs,
 which means they cannot communicate directly.
\end_layout

\end_deeper
\begin_layout Enumerate
TIA/EIA-568 and ISO/IEC_11801.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
\color brown
TIA/EIA-568
\series default
\color inherit
 is one of the main branches of the TIA standards,
 created by the Telecommunications Industry Association (TIA).
 It focuses on rules for structured cabling systems how to build Ethernet networks so that devices from different vendors work together.The standard defines cable categories like Cat5e,
 Cat6,
 Cat6a,
 and Cat8,
 each supporting different speeds and frequencies.
 It also describes how to wire and crimp RJ-45 connectors using two common schemes:
 T568A and T568B.
 Patch panels are also defined here,
 as well as maximum cable lengths and other installation rules.
 The main goal is to make sure network cables and equipment are compatible,
 reliable,
 and follow the same structured approach everywhere.
\end_layout

\begin_layout Itemize

\series bold
\color brown
ISO/IEC 11801
\series default
\color inherit
 is an international standard for structured cabling systems.
 It defines how to build universal cabling for offices,
 campuses,
 and other customer premises,
 so that different types of communication like Ethernet,
 telephony,
 and building control systems can work over the same infrastructure.This standard covers both twisted-pair copper cables and optical fiber.
 In many ways,
 it’s similar to TIA/EIA-568,
 but ISO/IEC 11801 is used globally,
 while TIA/EIA is mostly American.
 One important detail is that ISO includes Category 7 and 7a,
 but these are not recognized by TIA/EIA because there is no widespread hardware support for them.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
Ethernet cabling categories.

\series default
\color inherit
 For example,
 CAT 6.
 Cat6 is one of the most common Ethernet cables used today 
\shape italic
and backward compatible with the Category 5/5e and Category 3 cable standards
\shape default
 (From wikipedia) .
 It supports 1 Gbps up to 100 m and can handle 10 Gbps up to around 55 m,
 with a frequency of 250 MHz.
 The cable is widely used in offices,
 homes,
 small server rooms,
 IP cameras and VoIP systems,
 because it’s reliable,
 not too expensive,
 and still compatible with older equipment.
 In practice,
 Cat6 is a good balance between cost and performance,
 which is why it became the standard choice for most installations.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename cat6.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
8P8C (RJ-45)
\series default
\color inherit
 is the official name of the connector that people usually call RJ-45.
 The name means 8 Positions,
 8 Contacts,
 which describes the 8 pins inside the plug.
 This connector is used for Ethernet cables (Cat5e,
 Cat6,
 Cat6a,
 etc.) and lets devices like PCs,
 switches,
 and routers connect to each other.The term RJ-45 is technically not correct,
 because RJ-45 was originally a telephone standard,
 but in networking the name stuck and everyone uses it.
 In practice,
 when you say “RJ-45”,
 people understand it’s the standard Ethernet connector.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename rj45.png

\end_inset


\end_layout

\begin_layout Standard
21.
 
\series bold
\color brown
(IEEE 802.11ac,
 802.11ax,
 802.11be) 
\series default
\color inherit
These are different generations of the Wi\SpecialChar nobreakdash
Fi standard,
 each one improving speed,
 efficiency,
 and how many devices can work on the same network.
\end_layout

\begin_layout Itemize
802.11ac (Wi-Fi 5) works mostly on 5 GHz,
 supports channel widths up to 160 MHz,
 and gives speeds up to several Gbps.
 Introduced MU-MIMO,
 which lets multiple devices receive data in parallel instead of waiting one by one.
\end_layout

\begin_layout Itemize
802.11ax (Wi-Fi 6 / 6E) works on 2.4 GHz,
 5 GHz,
 and even 6 GHz (Wi\SpecialChar nobreakdash
Fi 6E).
 Improves MU-MIMO and adds OFDMA,
 splitting the channel into smaller sub-channels so more devices can transmit at the same time.
 Better performance in crowded environments and lower latency.
\end_layout

\begin_layout Itemize
802.11be (Wi-Fi 7) the newest generation.
 Uses channels up to 320 MHz wide and supports Multi-Link Operation (MLO) a device can use multiple frequency bands simultaneously for higher speeds and better stability.
 It also improves MU-MIMO even further,
 supporting up to 16 spatial streams and allowing many clients to send and receive data at the same time.
 Theoretical speeds can go above 40 Gbps.
\end_layout

\begin_layout Subsection

\color blue
Estimate how long does it take to download 3 TB file from cloud based backup service if network download throughput is 200 Mbps for actual payload (i.e.
 data)?
\end_layout

\begin_layout Itemize
Step 1 - Convert 3 TiB to bits (1 TiB = 1024⁴ bytes):
 
\begin_inset Formula $3\text{TiB}=3\times1024^{4}bytes=3.295\times10^{12}\text{bytes}\times8\text{byte}=2.636\times10^{13}\text{bits}$
\end_inset


\end_layout

\begin_layout Itemize
Step 2 - Divide by the payload throughput (200 Mbps):
 
\begin_inset Formula $T=\frac{2.636\times10^{13}bits}{200\times10^{6}\text{bits/s}}=1.318\times10^{5}s$
\end_inset


\end_layout

\begin_layout Itemize
Step 3 - Convert seconds to hours:
 
\begin_inset Formula $T_{\text{h}}=\frac{1.318\times10^{5}\text{s}}{3600s/h}\approx36.6h$
\end_inset


\end_layout

\begin_layout Standard
Answer:
 36.6 hours
\end_layout

\begin_layout Subsection

\color blue
Locate the MAC address of your mobile phone,
 laptop wifi interface or some other networked IT device
\end_layout

\begin_layout Standard

\color blue
How did you find it?
\end_layout

\begin_layout Standard

\color blue
List the MAC address in hex format (such as f0:1f:af:cf:d9:1a),
 but replace last 24 bits with zeros for your privacy
\end_layout

\begin_layout Standard

\color blue
Use OUI MAC address list(s) or lookup tools,
 and determine the device/chipset vendor of that MAC address.
 For example,
 that f0:1f:af:cf:d9:1a is Dell inc.
\end_layout

\begin_layout Standard
Device 1:
 Laptop (Arch Linux)
\end_layout

\begin_layout Standard
To find the MAC addr I used the ip link command in terminal.
 Wi-Fi interface is wlan0,
 its MAC address is shown next to link/ether.
\end_layout

\begin_layout Standard
MAC address:
\end_layout

\begin_layout Standard
6c:29:95:00:00:00 (last 24 bits zeroed for privacy)
\end_layout

\begin_layout Standard
Vendor (OUI lookup):
\end_layout

\begin_layout Standard
MAC prefix 6c:29:95 belongs to Intel Corporate
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Device 2:
 Android smartphone
\end_layout

\begin_layout Standard
How did you find it?
\end_layout

\begin_layout Standard
Went to:
\end_layout

\begin_layout Standard
Settings → About phone → Status → Wi-Fi MAC address
\end_layout

\begin_layout Standard
MAC address:
 ac:c0:48:00:00:00 (last 24 bits zeroed for privacy)
\end_layout

\begin_layout Standard
Vendor (OUI lookup):
 AC:C0:48 OnePlus Technology (Shenzhen) Co.,
 Ltd.
\end_layout

\begin_layout Standard
(Looked up using the Wireshark OUI Lookup Tool
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted2.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Describe shortly what are these network devices,
 functions,
 and services
\end_layout

\begin_layout Enumerate
Repeater
\end_layout

\begin_layout Enumerate
Hub (multiport repeater)
\end_layout

\begin_layout Enumerate
Bridge
\end_layout

\begin_layout Enumerate
Access switch
\end_layout

\begin_layout Enumerate
Core switch
\end_layout

\begin_layout Enumerate
Edge router
\end_layout

\begin_layout Enumerate
Core router
\end_layout

\begin_layout Enumerate
Firewall
\end_layout

\begin_layout Enumerate
Wifi AP
\end_layout

\begin_layout Enumerate
WLAN AP controller
\end_layout

\begin_layout Enumerate
Network TAP
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
Repeater
\series default
\color inherit
 is a device used in networks or telecom lines to help signals travel longer distances.
 When a signal gets weak or noisy,
 the repeater picks it up,
 regenerates it,
 and sends it out again.
 This way,
 the signal can reach further without losing quality or becoming unreadable.
 Repeaters are used for Ethernet cables,
 fiber optic links,
 and even wireless connections.
 There are different types of repeaters depending on the technology,
 for example,
 telephone,
 optical,
 or radio repeaters.
 The main point is that a repeater doesn’t just make the signal louder.
 Repeater actually rebuilds the data and removes most of the noise,
 so errors don’t add up as the signal moves through the network.
 If the signal is already too weak or too noisy,
 a repeater might not help,
 but usually it keeps the data clear over long distances.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Hub
\series default
\color inherit
,
 or multiport repeater,
 is a simple network device used to connect several computers or other devices in a local network,
 usually with Ethernet cables.
 When a device sends data to the hub,
 the hub copies that data and sends it out to all its ports,
 so every connected device gets the same message,
 no matter who it was meant for.
 This is why hubs work at the physical layer (Layer 1) and don't know anything about addresses or who is supposed to get the data.Because hubs just repeat everything to everyone,
 they don’t help with traffic management if two devices send data at the same time,
 their signals will collide,
 which causes errors and forces the devices to resend their data.
 For this reason,
 hubs have been replaced by switches in most modern networks,
 since switches are smarter and only forward data to the right device,
 reducing collisions and making the network faster.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Bridge
\series default
\color inherit
 is a network device that splits a network segment into two parts to help filter traffic and cut down on unnecessary data.
 When data frames arrive,
 the bridge checks their MAC addresses to see if the sender and receiver are on the same side.
 If they are,
 the bridge blocks the traffic from crossing over.
 If they’re on different sides,
 the bridge lets the data through.
 This way,
 bridges help reduce collisions and keep local traffic separate,
 making the network more efficient.
 Bridges work at the data link layer (Layer 2).
 They’re especially useful for breaking up a large,
 busy network into smaller,
 quieter sections.
 In modern networks,
 simple bridges aren’t used much anymore because switches can do the same thing (and more),
 but the main idea is the same:
 bridges help organize network traffic and stop unnecessary signals from spreading everywhere.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Access switch
\series default
\color inherit
 is a network switch used to connect end devices,
 like computers,
 printers,
 or phones,
 to the local network.
 It’s usually placed at the edge of the network,
 close to users,
 and has many ports for plugging in devices with Ethernet cables.
 The main job of an access switch is to forward data only to the specific device it’s meant for,
 using MAC addresses—
which means,
 when one device sends data,
 the switch checks the destination MAC address and sends that data only to the right port,
 not to everyone else.
 This keeps traffic organized and reduces collisions.Access switches work at Layer 2 (the data link layer) and often support extra features,
 like VLANs for segmenting traffic,
 or Power over Ethernet (PoE) for powering devices directly through the cable.
 In most networks,
 access switches connect user devices to higher-level switches or routers,
 forming the first step for devices to access the rest of the network.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Core
\series default
\color inherit
 
\series bold
\color brown
switch
\series default
\color inherit
 is a high-performance network switch that is located at the center of a large network and connects multiple access switches together.
 Its main job is to move large amounts of data between different parts of the network,
 especially between different buildings or sections of an organization.
 Core switches usually have very high bandwidth and fast processing to handle lots of simultaneous connections.
 Unlike access switches,
 core switches don’t connect directly to end devices like computers or printers they mostly connect to other switches and routers.
 They work at Layer 2 or sometimes Layer 3 (data link),
 and are designed for speed and reliability,
 making sure data can always get from one side of the network to the other.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Edge router 
\series default
\color inherit
is a network device (Layer 3) that sits at the boundary between an internal network (like a company or campus LAN) and an external network,
 usually the internet or another organization’s network.
 Its main job is to route traffic in and out of the local network,
 deciding which data goes where based on IP addresses.
 Edge routers also often handle things like NAT (Network Address Translation),
 firewall rules,
 VPNs,
 and sometimes basic security functions,
 protecting the internal network from outside threats.In short,
 the edge router acts as the main gateway between your private network and the outside world.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Core router
\series default
\color inherit
 is a high-capacity network device (Layer 3) located in the center of large networks,
 such as service provider backbones or big enterprise networks.
 Its main job is to quickly route large amounts of data between different parts of the network,
 connecting multiple edge routers and distribution switches.
 Core routers are optimized for speed,
 reliability,
 and handling high volumes of traffic,
 but they usually don’t connect directly to end devices.
 In summary,
 a core router forms the backbone of a big network,
 moving data efficiently between major segments.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Ffirewall
\series default
\color inherit
 is a security device or software that controls which data is allowed to enter or leave a network or a single computer based on a set of rules.
 Its main job is to block unwanted or dangerous traffic.
 Firewalls can be physical devices placed between networks,
 or software running on a computer or server.
 Firewalls check network packets for things like source and destination addresses,
 ports,
 and protocols.
 Based on this information,
 the firewall decides whether to allow or block the traffic.
 This helps protect networks from attacks,
 unauthorized access,
 and malware.
 In most modern networks,
 firewalls are used to separate private internal networks from the public internet,
 adding an important layer of defense.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
WiFi access point (AP)
\series default
\color inherit
 is a device that allows wireless devices,
 like laptops and smartphones,
 to connect to a wired network using Wi-Fi.
 The AP acts as a bridge between the wireless devices and the wired part of the network (for example,
 an Ethernet LAN).
 When you connect your phone or laptop to Wi-Fi,
 you’re actually connecting to the access point,
 which then forwards your data to the rest of the network.
 Wi-Fi APs handle radio communication,
 manage which devices can connect,
 and take care of basic security settings like passwords and encryption.
 In home networks,
 the AP is often built into the Wi-Fi router,
 but in bigger networks (like offices or schools),
 there are usually several standalone APs placed around the building to give good wireless coverage everywhere.In short,
 a Wi-Fi AP is what lets wireless devices join the local network and get access to the internet or other resources.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Wireless LAN controller (WLC)
\series default
\color inherit
 is a device or software that centrally manages multiple WiFi access points in large networks,
 like offices or campuses.
 Instead of configuring each access point separately,
 admins use the controller to set WiFi settings (such as passwords,
 network names,
 and firewall rules) once,
 and the changes apply to all APs automatically.
 The WLC also manages security,
 firmware updates,
 and load balancing across access points.
 Another key function is seamless roaming:
 as users move through the building,
 their devices can automatically switch between access points without losing connection,
 because the controller coordinates the 
\color violet
handover
\color inherit
 process.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Network TAP (Test Access Point)
\series default
\color inherit
 is a hardware device that’s used to monitor and capture network traffic for analysis.
 It sits between two points in the network and makes an exact copy of all the data passing through,
 sending it to a monitoring or security tool.
 Unlike a switch port in mirror mode,
 a TAP is a dedicated device,
 so it captures traffic without interfering or slowing down the network.Network TAPs are commonly used for network troubleshooting,
 security monitoring,
 or recording traffic for later analysis.
 They work at Layer 1 (physical layer) and are often used in data centers or anywhere reliable,
 passive network monitoring is needed.
\end_layout

\begin_layout Subsection

\color blue
RFC assignments
\end_layout

\begin_layout Enumerate
What are RFCs?
\end_layout

\begin_layout Enumerate
How many PPP related RFC documents can you find from rfc-editor website?
\end_layout

\begin_layout Enumerate
What is the current status of RFC1597?
 What is the number for updated,
 more recent RFC of same topic?
\end_layout

\begin_layout Enumerate
When was RFC5218 released?
\end_layout

\begin_layout Enumerate
What is the meaning if RFC status is BCP?
\end_layout

\begin_layout Enumerate
List authors of the CoAP RFC (June 2014).
 What is the RFC number?
\end_layout

\begin_layout Enumerate
Twitch.tv provides IRC access to the stream chats.
 Which RFC defines the original Internet Relay Chat (IRC) Protocol?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
An RFC (Request for Comments)
\series default
\color inherit
 is kind of like open-source documentation for how the internet works.
 Anyone engineers,
 researchers,
 or even just enthusiasts can write and submit an RFC if they have an idea or proposal about how something on the internet should work.
 The process is similar to making a pull request for code,
 but instead of merging changes,
 your RFC is published as its own document with a unique number if it gets accepted.
 Other experts can review,
 discuss,
 and suggest edits just like code review in open-source projects.
 If something needs to be changed later,
 a new RFC is created instead of editing the old one.
 All the discussions and documents are open and public.
 RFCs cover everything from technical standards (like TCP/IP,
 HTTP,
 DNS,
 email),
 to experiments,
 to even jokes.
 Some RFCs become official internet standards after enough review and consensus,
 but many are just for sharing information or starting a conversation in the community
\end_layout

\begin_layout Enumerate

\series bold
\color brown
How many PPP related RFC documents can you find from rfc-editor website?

\series default
 
\color inherit
According to the rfc-editor.org which i checked.
 I fount 111 RFC documents related to PPP (Point-to-Point Protocol).
 I used Title/Keyword search and got this:
 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted3.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What is the current status of RFC1597?
 What is the number for updated,
 more recent RFC of same topic?
 The current status of RFC1597 is Informational (it’s not an official standard,
 just a technical note).RFC1597 has been obsoleted by RFC1918,
 which is the updated and more widely used document on the same topic (private IP address ranges for IPv4).So,
 RFC1918 is the newer and active RFC covering this topic.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Graphics
	filename rfs1597.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard

\color brown
\begin_inset Graphics
	filename obsolated.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
When was RFC5218 released?

\series default
\color inherit
 Even though the timeline on the page shows November 2007,
 that’s just when the draft work started and the document was first discussed.
 The actual RFC was published later—
look at the “Type” line,
 which says “RFC - Informational (July 2008)”.For any report or official answer,
 you always use the publication date of the RFC itself,
 not the draft or discussion dates.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename RELEASERFC.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
BCP stands for Best Current Practice.

\series default
\color inherit
 If an RFC has the status BCP,
 it means it describes the best way to do something on the internet right now sort of like an official recommendation or guideline,
 but not a strict standard.
 BCPs are used for things that everyone should probably follow,
 but that might change over time as technology and best practices evolve.
 So,
 BCP = Best Current Practice = recommended way to do things at the moment,
 not a permanent standard.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
List authors of the CoAP RFC (June 2014).
 What is the RFC number?
 
\color violet
Authors:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
\color violet
Z.
 Shelby
\end_layout

\begin_layout Itemize

\series bold
\color violet
K.
 Hartke
\end_layout

\begin_layout Itemize

\series bold
\color violet
C.
 Bormann
\end_layout

\begin_deeper
\begin_layout Itemize
And the RFC number is RFC 7252.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename rfcauthors.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
Twitch.tv provides IRC access to the stream chats.
 Which RFC defines the original Internet Relay Chat (IRC) Protocol?
 
\series default
\color inherit
The answer is RFC 1459.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename IRC.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection

\color blue
What is OSI model?
 Compare OSI model to TCP/IP model
\end_layout

\begin_layout Standard

\color brown
The OSI (Open Systems Interconnection model)
\color inherit
 is a way to describe how network communication works by splitting everything into seven clear layers,
 each with its own job.
 It was created by ISO (International Organization for Standardization) in the 1980s,
 mostly to help different vendors’ equipment and software work together,
 and to give people a common language for talking about networks.
 Example:
 Sending an email (OSI pipeline) 
\end_layout

\begin_layout Itemize
Application layer :
 You write your message and hit “send” in your email app.
 The app uses a protocol like SMTP (Simple Mail Transfer Protocol) to format and send your message.
\end_layout

\begin_layout Itemize
Presentation layer:
 If your message uses special characters,
 emojis,
 or attachments,
 this layer makes sure the data is properly encoded (for example,
 turning your message into ASCII or UTF-8).
 If you’re using encryption (like TLS/SSL),
 this layer encrypts your email so only the right recipient can read it.
\end_layout

\begin_layout Itemize
Session layer:
 Your app opens a “session” or connection to your email server—
basically,
 it handles logging in,
 keeping the connection alive while your email is sent,
 and closing it when finished.
\end_layout

\begin_layout Itemize
Transport layer:
 This layer breaks your email into smaller pieces (“segments” or “packets”) and ensures they all get to the server reliably and in the right order.
 It uses protocols like TCP (Transmission Control Protocol) to handle lost packets or errors.
\end_layout

\begin_layout Itemize
Network layer:
 The system adds your and the server’s IP addresses to each packet.
 This layer figures out the best path for each packet to travel across the internet from your device to the destination.
\end_layout

\begin_layout Itemize
Data Link layer:
 Each packet gets wrapped in a “frame” with information like MAC addresses,
 so devices on your local network (like your router or Wi-Fi access point) know where to send it next.
\end_layout

\begin_layout Itemize
Physical layer:
 Finally,
 the data gets turned into electrical signals (if you’re on Ethernet),
 radio waves (if you’re on Wi-Fi),
 or pulses of light (if you’re on fiber).
 The signals travel through cables or wirelessly to the next device,
 starting their journey through the network.
\end_layout

\begin_layout Standard
The OSI model breaks everything into seven layers,
 but real-world networks including the whole Internet actually use the TCP/IP model,
 which has just four layers.
 In TCP/IP,
 some of the OSI layers are combined to keep things simple
\end_layout

\begin_layout Itemize
Link (covers OSI’s Physical and Data Link)
\end_layout

\begin_layout Itemize
Internet (same as OSI’s Network)
\end_layout

\begin_layout Itemize
Transport (same as OSI’s Transport)
\end_layout

\begin_layout Itemize
Application (combines OSI’s Session,
 Presentation,
 and Application)
\end_layout

\begin_layout Standard
The reason the TCP/IP model combines some of the OSI layers is because,
 in real life,
 there’s usually no need for separate “Session” or “Presentation” layers.
 Things like data formatting,
 encryption,
 and session management are almost always handled by the application itself or by libraries and protocols that sit at the Application layer.
 There aren’t special,
 separate protocols just for these jobs everything is built into how the application works.
 So,
 there was no point in keeping those layers separate.
 Fewer layers means less complexity,
 less overhead,
 and it’s easier for engineers to actually design and troubleshoot real networks.
 That’s why the TCP/IP model is simpler and lines up better with how the internet actually runs.
\end_layout

\begin_layout Part*
Week #2
\end_layout

\begin_layout Subsection

\color blue
What are VLANs and IEEE 802.1q?
\end_layout

\begin_layout Standard

\series bold
\color brown
VLAN (Virtual LAN)
\series default
\color inherit
 is a technology that splits one physical network into multiple logical networks.
 Normally,
 a switch without VLANs is one big broadcast domain:
 every device can hear every broadcast and send data to everyone else.
 VLANs break this domain into smaller,
 isolated ones.
 Devices in different VLANs cannot directly see each other’s traffic,
 even if they are connected to the same physical switch.
 This improves security,
 reduces unnecessary traffic,
 and keeps networks easier to manage.
 On a switch,
 VLANs are configured per port:
\end_layout

\begin_layout Itemize

\color violet
Access
\color inherit
 ports connect end devices (like PCs,
 printers,
 or phones).
 Each access port belongs to exactly one VLAN,
 and the device doesn’t need to know about VLANs —
 the switch automatically assigns all traffic from that port to the correct VLAN.
\end_layout

\begin_layout Itemize

\color violet
Trunk
\color inherit
 ports connect switches to each other,
 or a switch to a router or firewall.
 A trunk must carry traffic from multiple VLANs over a single cable.
\end_layout

\begin_layout Standard
To keep packets separated on a trunk,
 the
\series bold
\color brown
 IEEE 802.1Q standard
\series default
\color inherit
 is used.
 It adds a small VLAN tag into the Ethernet frame,
 containing the VLAN ID.
 When another switch receives the frame,
 it reads the tag and knows exactly which VLAN that packet belongs to.
 This allows VLAN 10,
 VLAN 20,
 and VLAN 30 to all share the same trunk link without getting mixed up.
 The advantage of this setup is centralized control:
 all VLANs can be delivered to one core switch,
 router,
 or firewall,
 where the administrator decides the rules which VLANs can talk to each other,
 which can only access the internet,
 and which are completely isolated.
 Without VLANs and trunking,
 you would need separate physical switches and cables for every network segment,
 which is costly and harder to manage.
\end_layout

\begin_layout Subsection

\color blue
Define following terms and concepts shortly:
\end_layout

\begin_layout Enumerate
ARP
\end_layout

\begin_layout Enumerate
ARP spoofing
\end_layout

\begin_layout Enumerate
HOP (networking)
\end_layout

\begin_layout Enumerate
IP TTL
\end_layout

\begin_layout Enumerate
IP TOS (DSCP)
\end_layout

\begin_layout Enumerate
DHCP,
 DHCP relay
\end_layout

\begin_layout Enumerate
WoL (Wake-on-LAN)
\end_layout

\begin_layout Enumerate
UPnP
\end_layout

\begin_layout Enumerate
Traceroute / Tracepath
\end_layout

\begin_layout Enumerate
Network Address Translation (NAT)
\end_layout

\begin_layout Enumerate
Tier 1 and 2 networks
\end_layout

\begin_layout Enumerate
Tier 3 ISP
\end_layout

\begin_layout Enumerate
Routing Autonomous System (AS or ASN for BGP)
\end_layout

\begin_layout Enumerate
127.0.0.1 address
\end_layout

\begin_layout Enumerate
::1 address
\end_layout

\begin_layout Enumerate
0.0.0.0/0 and ::/0 networks in the routing table
\end_layout

\begin_layout Enumerate
Ranges of IPv4 multicast and experimental addresses
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
ARP
\series default
\color inherit
 stands for Address Resolution Protocol.
 It was created in 1982 by David Plummer at MIT and described in RFC 826.
 The idea behind ARP is simple computers need to talk to each other over a network,
 and for that they use IP addresses.
 But on a physical level,
 like Ethernet or Wi-Fi,
 they actually send data to MAC addresses.
 So when a computer wants to send a packet to some IP like 192.168.1.1,
 it first needs to figure out what MAC address is linked to that IP.
 ARP does exactly that.
 It sends a broadcast message to the local network asking “who has this IP?”,
 and the device that owns that IP replies with its MAC.
 The computer then saves that info in its ARP table and uses it to send data directly.
 This is how communication works in IPv4 networks.
 In IPv6,
 ARP is replaced with a different protocol called Neighbor Discovery.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
ARP spoofing 
\series default
\color inherit
is when someone on the same local network pretends to be another device by sending fake ARP replies.
 Imagine you're connected to Wi-Fi and your computer asks "who has IP 192.168.1.1?" because it wants to talk to the router.
 The router replies with its real MAC address,
 but at the same time there's some guy nearby – let's call him Vasyan in dark sunglasses – and he also replies,
 saying that he is 192.168.1.1 and gives his own MAC address.
 Your computer just takes the last answer it gets and saves it in its ARP table.
 It doesn’t check who is telling the truth.
 Now all your traffic goes to Vasyan instead of the real router.
 He can read it,
 change it,
 or block it.This works because ARP is an old and dumb protocol.
 It accepts whatever answer comes,
 and always updates the ARP table with the latest reply.
 That’s why ARP spoofing is so easy to do – you just keep sending fake ARP replies every few seconds and you stay in control.To defend against this,
 people use static ARP entries,
 special tools that detect spoofing,
 or move to IPv6 where the system works differently and has more protection.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
HOP (networking)
\color inherit
.
 
\family sans
\series default
\shape italic
In networking,
 a hop is one step that a packet makes as it travels from one device to another.
 Every time it moves from one router or node to the next,
 that’s a hop.
 It’s like checkpoints on the way from sender to receiver.
 You can actually trace them using tools like traceroute,
 which shows how many hops your packet needs to reach a target.
 The more hops,
 the more delay and risk of packet loss.In IP networks,
 hops are limited by a field called TTL time to live.
 Each hop decreases the TTL by 1.
 If it reaches zero,
 the packet is dropped.
 This prevents endless loops in the network.To understand hops better,
 I wrote a small C++ simulation that models message propagation across a network of 10 000 nodes.
 Each node randomly picks 3 other nodes to send a message to (fanout = 3).
 I start with a single "mother node" and simulate how the message spreads across the network,
 counting how many hops it takes to reach each node.
 Every node keeps track of how many times it got the message and at what hop it arrived.
 This way,
 I can measure not just average hop count,
 but also how many duplicate messages appear,
 how many nodes were reached,
 and how much total traffic was generated.The simulation uses a custom stack-based message queue instead of dynamic containers like std::vector,
 to avoid heap allocation overhead.
 It runs multiple iterations and averages out the results.
 The final stats include average number of hops per reached node,
 total number of messages sent,
 and how much redundancy was created in the process.This model helped me get an intuitive feel for how information propagates in large random graphs,
 how fanout affects reachability,
 and what the typical hop distance is.
 It also ties back nicely to the concept of hops in real-world networking —
 the more intermediate points,
 the longer the path,
 and the more chances for noise or duplication.
 GitHub link to the code:
 
\series bold
\color violet
(https://github.com/igorbologovv/10KNodes/blob/main/node_jump.cpp)
\end_layout

\begin_layout Enumerate

\series bold
\color brown
TTL
\series default
\color inherit
 stands for Time To Live.
 Despite the name,
 it’s just a number inside an IP packet that limits how many hops the packet can make.
 Each time it passes through a router,
 TTL goes down by 1.
 When it hits zero,
 the packet is dropped.This prevents endless loops if routers misbehave.
 Without TTL,
 broken routing could flood the network.
 Tools like traceroute use TTL to map paths by sending packets with increasing TTL values and seeing where they get stopped.Different systems use different starting TTLs Linux might start at 64,
 Windows at 128,
 some devices use 255.
 So TTL can also help identify operating systems.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
TOS
\series default
\color inherit
 stands for Type of Service it’s a field in the IP header that was meant to tell the network how a packet should be treated.
 Over time,
 the old TOS system was replaced with DSCP,
 which stands for Differentiated Services Code Point.
 DSCP gives us 6 bits in the IP header to mark the priority of traffic basically,
 a way for the packet to say:
 “hey,
 I’m important” or “I can wait”.
 This is mostly used for Quality of Service (QoS).
 Routers and switches can read these DSCP values and decide how to queue or forward the packets.
 For example,
 voice packets (like from a Zoom call or VoIP app) are usually marked with DSCP 46 that means “low delay,
 treat me fast”.
 These packets are small,
 sensitive to delay,
 and can’t be buffered.
 Video calls might get DSCP 34 also high-priority,
 but not as strict as voice.
 On the other hand,
 file downloads or software updates are marked as best effort,
 which just means:
 “deliver me whenever”.And even chat messages over UDP might get their own DSCP level not as urgent as voice,
 but still more important than background traffic.
 This is especially useful when the network is under load.
 The whole idea is to make sure real-time stuff gets through first.
 Now,
 DSCP is not just for UDP.
 It works with all IP traffic UDP,
 TCP,
 ICMP,
 even encrypted VPN tunnels.
 The reason people often talk about UDP in this context is because it’s usually used for real-time traffic,
 where delays and packet loss really hurt.
 TCP traffic (like web browsing or file transfer) can also use DSCP,
 especially in finance or other systems that care about latency or reliability.
 But since TCP already has its own built-in mechanisms like retransmissions and congestion control DSCP has less impact there.So yeah,
 any packet can carry a DSCP value,
 but whether the network honors it depends on router configuration.
 In home networks,
 DSCP might be ignored.
 In corporate or ISP environments with QoS policies it matters a lot.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
DHCP (Dynamic Host Configuration Protocol)
\series default
\color inherit
 is a protocol that automatically assigns IP addresses,
 gateway,
 DNS,
 and other settings to devices when they join a network.
 In home networks,
 the router usually acts as the DHCP server,
 handing out private IPs from a preset range and keeping track of who got what.
 The router itself gets a public IP from the ISP via DHCP and uses NAT to let all local devices share that one public IP,
 tracking connections with a NAT table.
 
\series bold
\color brown
DHCP relay
\series default
\color inherit
 is used when the DHCP server is in a different subnet.
 The relay agent (usually a router or switch) forwards the client’s broadcast request to the real server and relays the response back,
 allowing centralized IP management in larger networks.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Wake-on-LAN (WoL)
\series default
\color inherit
 is a feature that lets you remotely turn on a computer over the local network by sending it a special packet called a magic packet.
 This packet contains the target device’s MAC address repeated several times,
 and it’s usually sent as a broadcast to the whole LAN.
 For WoL to work,
 the computer must support it at the hardware level (typically in the NIC and BIOS/UEFI),
 and it has to be in a low-power state,
 not completely shut off.
 The NIC listens passively on the network,
 and when it sees its MAC repeated in a magic packet,
 it triggers the system to power on.
 WoL doesn’t work over the internet directly,
 unless you set up port forwarding or VPN.
 It’s mainly used in local networks to wake up machines for remote access,
 updates,
 or maintenance.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
UPnP (Universal Plug and Play)
\series default
\color inherit
 lets devices on your local network automatically open ports on the router to make themselves accessible from the internet.This is useful because routers with NAT block all incoming connections by default,
 unless the user manually sets up port forwarding.With UPnP enabled,
 an app can request the router to open a specific port and forward any traffic from the internet to that device.This is used by games,
 torrent clients,
 or remote access tools so they can accept incoming connections without manual setup.The downside is security:
 any device in your local network can expose itself to the internet,
 which can be dangerous if malware is present.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Traceroute / Tracepath.

\series default
\color inherit
 When you're checking network problems,
 you usually start with ping it just tells you if the connection works.
 But if you want to know how the packets travel to the destination,
 you use traceroute or tracepath.
 Tracerout is the classic tool,
 it can send packets using UDP,
 TCP or ICMP,
 and works with both IPv4 and IPv6,
 it shows you every hop (router) between your device and the destination,
 and for each one,
 it prints 3 round-trip times (RTTs).
 You can even tweak the way packets are sent.
 But to do that,
 traceroute often needs root access because crafting custom or raw packets can be a security risk.
 Tracepath is the simpler and safer tool.
 It uses normal UDP packets and doesn’t need root.
 It can’t do advanced tricks,
 but it’s great for basic diagnostics,
 it shows similar output:
 each hop,
 its IP or hostname,
 and the round-trip time (but only once per hop).It also shows the MTU (maximum packet size allowed) along the path,
 which can help in certain cases.
 When to use which?For most cases,
 tracepath is enough and safer great for workstations and normal users.If you need more control or are troubleshooting complex network issues,
 use traceroute,
 possibly with sudo.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Network Address Translation (NAT)
\series default
\color inherit
 was invented because there aren’t enough public IPv4 addresses for every device.
 Instead of giving each device a unique global IP,
 your provider gives your home one public IP.
 Your router assigns private addresses (like 192.168.x.x) to all your devices,
 and keeps a table matching each device’s private IP and port to a unique public port.
 When a device goes online,
 the router replaces its private IP with the public IP,
 saves the mapping,
 and sends replies to the right device based on this table.
 Besides saving IP addresses,
 NAT adds privacy and basic security:
 devices inside your network are not directly visible from the internet.
 If you want to make something accessible from outside,
 you set up port forwarding on the router.
 
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Tier 1 and Tier 2 networks
\series default
\color inherit
 The internet is made up of many networks,
 but not all are equal.
 Tier 1 networks are the top-level backbone providers huge companies (like AT&T,
 Tata,
 NTT,
 Level 3/CenturyLink) that can reach every other network on the internet without paying anyone else for transit.
 They do this by peering directly with all other Tier 1 networks and exchanging traffic for free (settlement-free peering).
 Tier 1s basically form the "core" of the global internet.
 Tier 2 networks are a level below.
 They usually have to pay Tier 1 networks for access to some parts of the internet (this is called IP transit),
 but they may also peer directly with other Tier 2s and smaller networks.
 ISPs (Internet Service Provider),
 regional carriers,
 and large hosting providers are often Tier 2.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Tier 3 ISPs
\series default
\color inherit
 are local or regional internet providers that connect homes and small businesses to the internet.
 They don’t have their own global backbone;
 instead,
 they buy all their internet access from bigger ISPs (Tier 2 or Tier 1 networks).
 Tier 3 providers focus on last-mile delivery and customer support,
 making sure users in their area get connected.
 Most people get their internet from a Tier 3 ISP,
 which acts as the final step between you and the wider internet.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Routing Autonomous System (AS or ASN for BGP)
\series default
\color inherit
.
 The global internet is made up of thousands of Autonomous Systems (AS).
 Each AS is a large group of IP addresses managed by one organization (like an ISP,
 big company,
 or university),
 and is identified by a unique ASN (Autonomous System Number).
 To create your own AS,
 you first need to officially receive a big block of public IP addresses (from a regional registrar like RIPE,
 ARIN,
 or APNIC) and then register an ASN.
 Only after that can you connect to other networks as a separate AS and use BGP to exchange routes.
 Once you have your own IP range and ASN,
 you can peer with other ASes,
 sell IP space to other providers,
 and even provide internet to others just like the big players.
 ASes use BGP (Border Gateway Protocol) to advertise which IP ranges they can route.
 This is how the global routing table is built,
 and why traffic knows which path to take across the world.
 Tier 1 AS:
 giant backbones,
 connect directly to all other Tier 1s,
 never pay for transit.
 Tier 2 AS:
 buy internet from Tier 1,
 may peer with others.
 Tier 3 AS:
 connect end-users,
 buy all connectivity from higher tiers.
 Every ISP,
 hosting company,
 or cloud provider is an AS.
 The AS system allows the internet to scale,
 set routing and security rules,
 and ensures redundancy (multiple paths).
 When you go online,
 your data travels from your home LAN (private IPs/NAT),
 through your Tier 3 ISP’s AS,
 up through bigger ASes,
 all connected and managed using BGP.
 So,
 if you own a large enough block of public IPs and get your own ASN,
 you can become an AS yourself connect to other networks,
 sell IP space,
 and become part of the global backbone.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
127.0.0.1
\series default
\color inherit
 is the “loopback” address,
 also known as localhost.
 When your computer sends data to 127.0.0.1,
 it never leaves the machine the data just loops back and stays inside.
 This address is used for testing,
 running local servers,
 and letting programs talk to each other on the same computer without any network hardware.
 Every device reserves 127.0.0.1 for itself;
 it’s never used to reach other devices.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
::1
\series default
\color inherit
 is the IPv6 loopback address,
 the same as 127.0.0.1 in IPv4.
 It lets your computer send data to itself without touching the network useful for local testing and running servers on your own machine.
 IPv6 is the new version of the internet protocol,
 made because IPv4 addresses ran out.
 IPv6 uses much longer addresses (like 2001:0db8:85a3::8a2e:0370:7334) and has enough space for every device in the world to get a unique IP.
 With IPv6,
 ::1 is always reserved as the loopback address for local use.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
0.0.0.0/0 and ::/0 networks in the routing table.

\series default
\color inherit
 Every router or device on the network keeps a routing table,
 which tells it where to send packets for different IP ranges.
 When a packet arrives,
 the router checks if it has a specific route for the destination IP.
 If yes,
 it forwards the packet along that path.
 If it doesn’t have a matching route,
 it uses the default route (0.0.0.0/0 for IPv4 or ::/0 for IPv6) to send the packet to its default gateway or the next higher-level router.
 Each router along the way repeats this process until the packet reaches a network that knows how to deliver it to the final destination.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Ranges of IPv4 multicast and experimental addresses.
 
\series default
\color inherit
Multicast is a way to send one packet to multiple receivers at the same time but not to everyone (like broadcast),
 just to devices that joined a specific group.
 It’s used for things like streaming video to a group,
 online games,
 or letting devices find each other on the local network.
 The multicast range is 224.0.0.0 to 239.255.255.255,
 but not all addresses are used the same way:
 
\end_layout

\begin_layout Itemize
224.0.0.0 to 224.0.0.255 For network control and discovery inside the local network only.
 These addresses are used by routers and protocols like OSPF,
 RIP,
 or mDNS,
 and never leave the local subnet.
 Example:
 224.0.0.1 means “all devices on this subnet”.
\end_layout

\begin_layout Itemize
224.0.1.0 to 238.255.255.255 For general multicast applications.
 These addresses can be routed across networks if allowed.
 Used for things like IPTV,
 large group calls,
 or multi-site streaming.
\end_layout

\begin_layout Itemize
239.0.0.0 to 239.255.255.255 For private multicast inside a company or organization.
 These addresses are not supposed to be routed on the public internet,
 only inside your organization’s network.
 Like “private IPs” but for multicast.
 Experimental addresses (240.0.0.0 to 255.255.255.254) are reserved and not used in the public internet.
\end_layout

\begin_layout Subsection

\color blue
Search some information about AS1741
\end_layout

\begin_layout Enumerate
Which organisation or company advertises AS1741 with BGP?
\end_layout

\begin_layout Enumerate
List some public peering exchange points the AS1741 connects to?
\end_layout

\begin_layout Enumerate
To which regional internet registry (RIR) the AS1741 belongs to?
\end_layout

\begin_layout Enumerate
What is the contact email address/phone/web form if you would need to inform some security or abuse issues to the owner of the AS1741?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
Which organisation or company advertises AS1741 with BGP?

\color inherit
 
\series default
I searched for AS1741 on bgp.he.net and found that it is advertised by CSC - Tieteen tietotekniikan keskus Oy,
 which is known as Funet.
 This is Finland’s national research and education network.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename tieteentech.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
List some public peering exchange points the AS1741 connects to.
\end_layout

\begin_deeper
\begin_layout Standard
I visited peeringdb.com and found a list of public peering exchange points for AS1741.
 According to the information on the site (see screenshot below),
 AS1741 is connected to several IXPs in Finland,
 including:
\end_layout

\begin_layout Itemize
FICIX 1 (Espoo) 100G
\end_layout

\begin_layout Itemize
FICIX 2 (Helsinki) 100G
\end_layout

\begin_layout Itemize
FICIX 3 (Oulu) 10G
\end_layout

\begin_layout Itemize
TREX Tampere 10G
\end_layout

\begin_layout Standard
For each IXP,
 both IPv4 and IPv6 connections are listed.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename peering.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
To which regional internet registry (RIR) the AS1741 belongs to?
\end_layout

\begin_deeper
\begin_layout Standard
I checked ipinfo.io where it says that the “Registry” for AS1741 is RIPE (Réseaux IP Européens) which is the Regional Internet Registry for Europe.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ripe.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
What is the contact email address/phone/web form if you would need to inform some security or abuse issues to the owner of the AS1741?
\end_layout

\begin_deeper
\begin_layout Standard
All related information about the security is on below screenshot.
 AS1741 is owned and operated by CSC - Tieteen tietotekniikan keskus Oy,
 the Finnish national research and education network provider (Funet).:
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename security.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection

\color blue
What it the difference between static and dynamic routing?
 Use example(s)
\end_layout

\begin_layout Standard
The difference between static and dynamic routing is that static routing relies on routes that are manually configured by a network administrator,
 while dynamic routing allows routers to automatically learn and update routes using special protocols.
 With static routing,
 the network administrator sets up specific paths for traffic,
 and these routes do not change unless someone manually edits them.
 This method is simple and works well for small or stable networks,
 but if something in the network changes,
 like a link fails,
 the route will not update on its own.
 For example,
 in a small office,
 an administrator might add a static route telling Router A to send all traffic for a certain network through Router B.
 If Router B goes offline,
 the connection breaks until someone changes the route manually.
 In contrast,
 dynamic routing uses protocols like OSPF,
 RIP,
 or BGP,
 which enable routers to share information about the network and automatically adjust routes if the network changes.
 This is useful in larger or more complex networks,
 because if a link fails or a new router is added,
 the system will quickly update itself and find the best available path without human intervention.
 In summary,
 static routing is manual and straightforward,
 but does not adapt to changes,
 while dynamic routing is automated and flexible,
 able to respond to changes in real time.
\end_layout

\begin_layout Subsection

\color blue
Describe briefly these dynamic routing protocols
\end_layout

\begin_layout Enumerate
RIP
\end_layout

\begin_layout Enumerate
OSPF and IS-IS
\end_layout

\begin_layout Enumerate
BGP
\end_layout

\begin_layout Enumerate
RPL (ripple)
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
RIP (Routing Information Protocol)
\series default
\color inherit
 is a classic distance-vector routing protocol that was one of the first dynamic protocols used in TCP/IP networks.
 RIP works by having routers periodically (every 30 seconds) exchange information with their neighbors about how many hops it takes to reach various networks.
 Each router keeps a simple routing table with the shortest hop count to each destination.
 The protocol is very easy to configure and understand,
 making it popular for small or simple networks.
 However,
 RIP has several limitations:
 it only allows up to 15 hops,
 which means it cannot be used in large networks,
 and it is slow to react to changes,
 so convergence (the process of all routers learning the best paths) can take a long time.
 Also,
 because it only cares about hop count and not bandwidth or delay,
 it may choose suboptimal paths.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
OSPF and IS-IS
\series default
\color inherit
 are both modern routing protocols used mostly inside large organizations and by internet providers.
 They don’t just look at the number of hops,
 like older protocols,
 but actually build a complete map of the network by exchanging information between all routers.
 Each router then figures out the best route to any destination using an algorithm called Dijkstra’s,
 which basically finds the shortest path.
 OSPF is made specifically for IP networks and divides them into smaller “areas” to keep things organized and efficient.
 IS-IS works in a very similar way,
 but it was first created for a different kind of network (the OSI model),
 and over time it turned out to be super flexible and reliable so now it’s also used by a lot of big ISPs.
 Both protocols can react quickly if something changes or breaks in the network,
 and they have features like security and load balancing that make them suitable for complex setups.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
BGP,
 or Border Gateway Protocol
\series default
\color inherit
,
 is basically the protocol that keeps the global Internet running.
 It decides how data gets from one big network (like an ISP or a company) to another,
 all around the world.
 Unlike older routing protocols that just look for the shortest or fastest path,
 BGP lets networks set their own rules for which routes to use for example,
 preferring cheaper or faster connections,
 or avoiding certain networks altogether.
 Routers using BGP talk to each other and exchange lists of which networks they can reach,
 plus extra info about how to get there,
 like the list of networks (AS numbers) the data would pass through.
 The cool thing about BGP is that it’s super flexible and powerful,
 so it can handle the massive scale of the whole Internet.
 But because it’s so important and complex,
 configuring BGP wrong can accidentally mess up the Internet for millions of people and that’s happened before.
 So BGP gives you a lot of control,
 but it also means you have to be careful.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
RPL (Routing Protocol for Low-power and Lossy Networks)
\series default
\color inherit
,
 sometimes called “ripple,” is a special routing protocol made for Internet of Things (IoT) setups think sensors,
 smart meters,
 or tiny devices running on batteries that connect over spotty wireless networks.
 The main idea behind RPL is to help these devices find reliable paths to send their data to a central hub or gateway,
 even if some connections are weak or keep changing.
 Instead of regular routing tables,
 RPL builds a sort of flexible tree (called a DODAG),
 which lets data flow around problems like dead links or devices that drop offline.
 It takes into account things like link quality or how much energy devices have left,
 so it can pick the most efficient routes.
 That’s why RPL works really well in places like smart homes,
 factories with lots of sensors,
 or city-wide smart infrastructure anywhere there are lots of simple,
 wireless devices that need to get their data back to a main server,
 even if the network is kind of unreliable.
\end_layout

\begin_layout Subsection

\color blue
Create a DNS request (any tool such as ping,
 nslookup,
 whatever) to resolve the IP address of www.oamk.fi
\end_layout

\begin_layout Enumerate
Use some IP whois lookup web service to resolve which company is hosting and has that IP address and server?
 (www.oamk.fi)
\end_layout

\begin_layout Enumerate
What is the inetnum or route/network (IP address range) the www.oamk.fi's IP address belongs to?
\end_layout

\begin_layout Enumerate
What is abuse contact email address of that network range?
\end_layout

\begin_layout Standard
I used the ping command to find out the IP address of www.oamk.fi.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted8.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I ran the whois command on this IP to see who owns it and which network it belongs to.
 The output said that the IP address is part of the range 95.216.0.0 - 95.217.255.255,
 and that this whole network is managed by Hetzner Online GmbH,
 which is a German hosting company.
 In the same whois result,
 I also found the abuse contact email for this network,
 which is abuse@hetzner.com
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted9.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Use traceroute (tracert in MS Windows command shell) to www.whitehouse.gov
\end_layout

\begin_layout Standard
What is the internet service provider's first router IP address near you?
 (it's most likely the 2nd router/hop,
 immediately after your home network)
\end_layout

\begin_layout Enumerate
How many hops (routers) are there to the www.whitehouse.gov from your device?
\end_layout

\begin_layout Enumerate
Use traceroute again,
 but this time to Google's public DNS server in 8.8.8.8,
 and Quad9 DNS in 9.9.9.9.
 How far are those?
\end_layout

\begin_layout Enumerate
Why traceroute does not always work,
 and does not show the route up to the final destination IP,
 or there are timeouts for some routers (* is timeout)?
 For example,
 IP address of education.gov.au
\end_layout

\begin_layout Enumerate
Use traceroute and DNS to estimate/guess from response DNS names,
 round trip times,
 and with IP whois lookups,
 where the web server reliefweb.int is located (continent,
 country or so)?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate
The first hop is my home router (192.168.1.1),
 and the second hop (91.159.136.2) is most likely the first router of my Internet service provider.
 The traceroute shows a total of 7 hops before timeouts start appearing.
 The route does not reach all the way to the destination,
 which is common due to network security settings and firewalls that block traceroute probes.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted10.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
After that,
 I ran traceroute to Google’s public DNS server (8.8.8.8) and to Quad9 DNS (9.9.9.9).
 For 8.8.8.8,
 the traceroute reached the destination in 7 hops (the 7th hop was 108.170.238.171,
 which is part of Google’s network).
 For 9.9.9.9,
 the traceroute only showed 4 hops before getting only timeouts (stars) for the rest,
 which means the packets reached the Quad9 DNS network (the last visible hop was 195.140.192.28,
 which is in Tampere,
 Finland),
 but further hops were not shown,
 possibly due to firewalls or network restrictions.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted11.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Traceroute does not always show the route all the way to the final destination because some routers or firewalls on the path are configured to ignore or block the traceroute packets (ICMP or UDP).
 This is often done for security reasons,
 to prevent outside users from mapping internal network structure or to reduce unnecessary network load.
 When a router does not respond,
 traceroute will show a star (*) and a timeout for that hop.
 For some websites,
 like education.gov.au,
 the final server or several routers near the end may not respond at all,
 so the route appears incomplete,
 even if the website itself is working.
 This is normal and expected on many networks.
\end_layout

\begin_layout Enumerate
To estimate where the web server for reliefweb.int is located,
 I used traceroute and saw that the last responding hop was nyk-b17-link.ip.twelve99.net (62.115.137.15).
 I am not sure about the exact location of this router,
 but then I checked the IP address of reliefweb.int (52.87.133.138) using whois.
 The whois result showed that this address belongs to Amazon Technologies Inc.
 (AWS) in Seattle,
 United States.
 So,
 even though the traceroute did not reach the actual server,
 based on the whois lookup I can say that reliefweb.int is hosted on AWS in the US.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename traceroute-nyk.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Use Ficix statistics web page and answer:
\end_layout

\begin_layout Enumerate
What is the most quiet IP traffic hour in the Ficix 1 exchange point?
\end_layout

\begin_layout Enumerate
Which organisations or companies are connected to Ficix 3?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
According to the Ficix 1 statistics page,
 the most quiet IP traffic hour was approximately between 03:00–06:00 (EEST),
 when the traffic dropped to its lowest value.
 This is clearly visible on the traffic graph,
 where both inbound and outbound traffic reached their minimum during this time.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted12.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
According to the Ficix statistics page,
 the following organisations and companies are connected to Ficix 3:
 CSC,
 Cinia,
 DNA,
 Elisa AS719,
 FNE,
 GleSYS,
 Kaisanet,
 Lounea,
 Telia,
 and Valoo:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted13.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
List all private IPv4 networks (RFC1918)
\end_layout

\begin_layout Standard
The private IPv4 networks defined by RFC1918 are:
\end_layout

\begin_layout Itemize
10.0.0.0 – 10.255.255.255 (10/8 prefix)
\end_layout

\begin_layout Itemize
172.16.0.0 – 172.31.255.255 (172.16/12 prefix)
\end_layout

\begin_layout Itemize
192.168.0.0 – 192.168.255.255 (192.168/16 prefix)
\end_layout

\begin_layout Standard
These address ranges are reserved for use in private networks and are not routed on the public internet.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted14.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
What is the purpose of IPv4 private networks?
\end_layout

\begin_layout Standard
The main purpose of IPv4 private networks is to help deal with the shortage of public IPv4 addresses,
 by letting different networks use the same private address ranges internally.
 This way,
 organizations and home users can connect as many devices as they want without taking up public address space.
 Besides saving addresses,
 private networks also make it easier to organize and manage local networks,
 because internal traffic can stay within the local network and does not have to travel over the public internet.
 Private addresses also improve security,
 since devices with private IPs are not reachable directly from outside you need special rules or port forwarding to allow access from the internet.
 In summary,
 private networks help save public IP addresses,
 make local networking simpler,
 and add a basic layer of security.
\end_layout

\begin_layout Subsection

\color blue
List and explain three or more purposes and features of the ICMP and or ICMPv6 protocol
\end_layout

\begin_layout Standard
ICMP (Internet Control Message Protocol) and its IPv6 version,
 ICMPv6,
 are protocols that work together with IP at the network layer (layer 3) of the OSI model.
 Their main purpose is not to transfer user data,
 but to send control and error messages that help manage and troubleshoot networks.
 One important feature of ICMP is error reporting.
 If a router cannot deliver a packet for example,
 because the destination is unreachable,
 the network is down,
 or a port is blocked it sends back an ICMP “Destination Unreachable” message to the sender.
 Another key feature is handling situations where packets loop around the network:
 if the “time to live” (TTL) of a packet reaches zero,
 the router sends an ICMP “Time Exceeded” message,
 which helps prevent endless loops.
 ICMP is also the foundation for network diagnostic tools.
 The most common example is the ping command,
 which uses ICMP Echo Request and Echo Reply messages to test if another device is reachable and to measure round-trip time.
 The traceroute tool uses ICMP messages to discover the path packets take through the network,
 by intentionally causing TTL to expire at each hop and recording the routers that respond.
 In IPv6,
 ICMPv6 has even more responsibilities.
 It not only does error reporting and diagnostics,
 but also supports Neighbor Discovery,
 which lets devices on the same local network automatically find each other,
 learn each other's addresses,
 and even configure their own IPv6 addresses without manual setup.
\end_layout

\begin_layout Subsection

\color blue
Try to solve these basic IP subnet calculations without checking the solutions:
\end_layout

\begin_layout Enumerate
If network address is 192.168.100.0,
 and subnet mask is 255.255.255.224,
 what is the broadcast address of the network?
\end_layout

\begin_layout Enumerate
If network address is 1.2.3.4,
 and broadcast address is 1.2.3.7,
 what is the subnet mask of the network?
\end_layout

\begin_layout Enumerate
If broadcast address is 192.168.129.255 and network mask is 255.255.254.0,
 what is the network address of the network?
\end_layout

\begin_layout Standard
A subnet mask is a number used in IP networking to separate the network part of an IP address from the host part.
 Technically,
 a subnet mask is just a sequence of 32 bits,
 written as four numbers separated by dots (for example,
 255.255.255.0).
 Each of these numbers is actually a group of eight bits.
 The reason we usually see subnet masks written in decimal (like 255.255.255.224) is simply because it’s easier for humans to read,
 but computers always work with them in binary (ones and zeros).
 For example,
 the mask 255.255.255.224 looks like this in binary:
 11111111.11111111.11111111.11100000.
 The “1” bits mean “network part,” and the “0” bits mean “host part.” So here,
 the first 27 bits are for the network,
 and the last 5 bits are for devices in that network.
 Some common subnet masks and what they look like in both decimal and binary:
\end_layout

\begin_layout Itemize
255.255.255.0 (/24):
 11111111.11111111.11111111.00000000 —
 256 addresses per network
\end_layout

\begin_layout Itemize
255.255.255.128 (/25):
 11111111.11111111.11111111.10000000 —
 128 addresses per network
\end_layout

\begin_layout Itemize
255.255.255.224 (/27):
 11111111.11111111.11111111.11100000 —
 32 addresses per network
\end_layout

\begin_layout Standard
Subnet masks are important because they help devices figure out which other devices are “local” and which ones are on another network,
 and they make it possible to split large networks into smaller,
 easier-to-manage parts.
\end_layout

\begin_layout Enumerate
If the network address is 192.168.100.0 and the subnet mask is 255.255.255.224:
 
\end_layout

\begin_deeper
\begin_layout Enumerate
The mask 255.255.255.224 is 27 ones and 5 zeros in binary,
 so the block size is 32 addresses (2⁵ = 32).
\end_layout

\begin_layout Enumerate
The network address is 192.168.100.0.
 
\end_layout

\begin_layout Enumerate
The broadcast address is the last address in the block:
 192.168.100.31.
 So the broadcast address for this network is 192.168.100.31.
\end_layout

\end_deeper
\begin_layout Enumerate
The answer is pretty easy to make we calculate 7-[4](4 included) = 4 addresses,
 4 = 2^2 so only 2 bits are free and the adjusting mask from the table for 30 ones is 255.255.255.252
\end_layout

\begin_layout Enumerate
254 in binary form is 11111110.
 The fourth number has 8 zeros.
 Altogether,
 there are 9 zeros in the mask,
 which means 2^9 = 512 addresses in the subnet.
 Since the broadcast address is 192.168.129.255,
 we need to count 512 addresses backwards to find the network address.
 The last bit in the 129 part represents only one address,
 so when we subtract this range,
 we go back to 128.
 With all the last 8 bits as zeros,
 the final result is 192.168.128.0.
\end_layout

\begin_layout Subsection

\color blue
Try to solve these IP subnetting assignments without checking the solutions and document at least some examples/answers to the learning diary.
 Answers should contain (for each subnet):
 Network address,
 broadcast address and subnet mask:
\end_layout

\begin_layout Itemize
Subnetting task 1:
 The address space available is 172.16.64.0/23.
 Subnet it and create 5 (A,
 B,
 C,
 D and E) IPv4 subnets with following amount of hosts in each network:
 A = 85,
 B = 45,
 C = 95,
 D = 57,
 E = 34.
 Leave some small amount of free addresses to each subnet.
 Avoid unnecessary waste of IPs.
\end_layout

\begin_layout Itemize
Subnetting task 2:
 Same as task 1,
 but available address space is now 192.168.0.0/25 and networks/hosts are:
 A = 28,
 B = 10,
 C = 60,
 D = 4.
 Leave some small amount of free addresses to each subnet.
 Avoid unnecessary waste of IPs.
\end_layout

\begin_layout Itemize
Subnetting task 3:
 IPv6 address space available:
 2001:708:510::/48.
 Create four /64 IPv6 networks.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Subnetting task 1
\series default
\color inherit
 .
 So 172.16.64.0/23.
 This means we have the same situation as in the previous task:
 the subnet mask has 9 zeros,
 which gives us 512 available addresses.
 When creating subnets,
 the number of hosts probably does not include the broadcast address,
 but each subnet must have the last address reserved for broadcast.
 As we already know,
 there are 512 addresses in total.
 We could just divide the 512 addresses evenly into 5,
 but we want to avoid wasting extra IPs.
 So,
 for each subnet,
 I add 2 to the required number of hosts (to account for the network and broadcast addresses),
 then choose the next power of two as the subnet size.
\end_layout

\begin_deeper
\begin_layout Enumerate
85 + 2 = 87 capacity 128
\end_layout

\begin_layout Enumerate
45 + 2 = 47 capacity 64
\end_layout

\begin_layout Enumerate
95 + 2 = 97 capacity 128
\end_layout

\begin_layout Enumerate
57 + 2 = 59 capacity 64
\end_layout

\begin_layout Enumerate
34 + 2 = 36 capacity 64
\end_layout

\begin_layout Standard
So the total is 128 + 64 + 128 + 64 + 64 = 448bits for all subnets together.
\end_layout

\begin_layout Standard
It is important to mention that we use powers of two not by chance,
 but because subnetting is based on bits,
 and we need to keep all subnet blocks aligned,
 with no gaps or overlaps.
 In the next step,
 I will arrange (“stretch out”) these blocks in a line,
 starting from 172.16.64.0,
 so that each subnet directly follows the previous one.
 Also the subnet is not that difficult to count we just see the amount of addresses and 255 - this amount + 1.
 and that would be the subnet mask /25 and /26 in the answer means exacley about that bit which we subtracted in a previous task.
\end_layout

\begin_layout Enumerate
for A :
 172.16.64.0 - 172.16.64.127 (capacity 128);
 Broadcast is the last in this range (172.16.64.127) ;
 Subnet mask:
 255.255.255.128/25.
\end_layout

\begin_layout Enumerate
C I will use straight after A because it is easier to count :
 C :
 172.16.64.128 - 172.16.64.255 (capacity 128);
 Broadcast is the last in this range (172.16.64.255);
 Subnet mask:
 255.255.255.128/25.
\end_layout

\begin_layout Enumerate
for B :
 172.16.65.0 - 172.16.65.63 (capacity 64) ;
 Broadcast is the last in this range 172.16.65.63;
 Subnet mask:
 255.255.255.192/26.
\end_layout

\begin_layout Enumerate
for D :
 172.16.65.64 - 172.16.65.127 (capacity 64) ;
 Broadcast is the last in this range 172.16.65.127;
 Subnet mask:
 255.255.255.192/26.
\end_layout

\begin_layout Enumerate
for E :
 172.16.65.128 - 172.16.65.191 (capacity 64);
 Broadcast is the last in this range 172.16.65.191;
 Subnet mask:
 255.255.255.192/26.
\end_layout

\begin_layout Enumerate
The remaining addresses (172.16.65.192 —
 172.16.65.255) are left free and can be used for future networks.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
Subnetting task 2
\series default
\color inherit
 :
 192.168.0.0/25 Is a total space of IPs means we have 7 zeros.
 So the mask would be 255.255.255.128/25.
 Then we use absolutely the same algorythm as in the previous task.
 I will skip some steps since I showed them in the task 1 and I will list pnly the answers in decreasing mode:
\end_layout

\begin_deeper
\begin_layout Enumerate
capacity = 64
\end_layout

\begin_layout Enumerate
capacity = 32
\end_layout

\begin_layout Enumerate
capacity = 16
\end_layout

\begin_layout Enumerate
capacity = 8
\end_layout

\begin_layout Standard
sum = 120
\end_layout

\begin_layout Standard
free IPs left = 128 - 120 = 8.
\end_layout

\begin_layout Enumerate
(c) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.0 – 192.168.0.63;
 192.168.0.63;
 255.255.255.192 (/26)
\end_layout

\begin_layout Enumerate
(a) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.64 – 192.168.0.95;
 192.168.0.95;
 255.255.255.224 (/27)
\end_layout

\begin_layout Enumerate
(b) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.96 – 192.168.0.111;
 192.168.0.111;
 255.255.255.240 (/28)
\end_layout

\begin_layout Enumerate
(d) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.112 – 192.168.0.119;
 192.168.0.119;
 255.255.255.248 (/29)
\end_layout

\end_deeper
\begin_layout Standard

\series bold
\color brown
Subnetting task 3
\series default
\color inherit
:
 The /48 prefix means that the first three blocks (2001:708:510) are fixed for all addresses in this range.
 To create four /64 subnets,
 we use the next (fourth) block as the subnet number and set it to 0,
 1,
 2,
 and 3.
 Each subnet will look like this:
\end_layout

\begin_layout Itemize
2001:708:510:0::/64
\end_layout

\begin_layout Itemize
2001:708:510:1::/64
\end_layout

\begin_layout Itemize
2001:708:510:2::/64
\end_layout

\begin_layout Itemize
2001:708:510:3::/64
\end_layout

\begin_layout Standard
In IPv6,
 there are no broadcast addresses,
 so you don’t need to reserve anything for broadcast.
 Each /64 subnet has a huge number of available addresses,
 and this method of subnetting is standard in IPv6.
\end_layout

\begin_layout Part*
Week #3
\end_layout

\begin_layout Subsection

\color blue
Answer these questions:
 
\end_layout

\begin_layout Enumerate
Explain shortly the purpose of TCP acknowledgment and sequence numbers
\end_layout

\begin_layout Enumerate
What is the purpose of TCP SYN bit?
\end_layout

\begin_layout Enumerate
What is the purpose of TCP reset bit?
\end_layout

\begin_layout Enumerate
When TCP retransmissions occur?
\end_layout

\begin_layout Enumerate
What is flow-control?
 (for IP family protocols such as TCP)
\end_layout

\begin_layout Enumerate
Explain TCP connection state LISTENING
\end_layout

\begin_layout Enumerate
Explain TCP connection state ESTABLISHED
\end_layout

\begin_layout Enumerate
What is the purpose of TCP or UDP source port?
\end_layout

\begin_layout Enumerate
What is the purpose of TCP or UDP destination port?
\end_layout

\begin_layout Enumerate
What are the common well-known network service names for these TCP ports:
 22,
 23,
 25,
 80,
 443,
 3306?
\end_layout

\begin_layout Enumerate
What are common connection-oriented protocol features/advantages,
 and why TCP is such protocol?
\end_layout

\begin_layout Enumerate
What are connectionless protocols features (or lack of),
 and why UDP is connectionless protocol?
\end_layout

\begin_layout Enumerate
Why most services using UDP prefer max 512 byte UDP datagrams?
\end_layout

\begin_layout Enumerate
When it is more reasonable to use UDP instead of TCP?
\end_layout

\begin_layout Enumerate
What is the length of TCP header without extra options?
 What about UDP header?
\end_layout

\begin_layout Enumerate
What is TCP Nagle’s algorithm?
 When it should be disabled for networking applications?
\end_layout

\begin_layout Enumerate
What is Maximum Transmission Unit (MTU) and IPv4 fragmentation?
\end_layout

\begin_layout Enumerate
What is a raw socket?
\end_layout

\begin_layout Enumerate
What is port forwading?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate
When you send data over TCP,
 it gets split into small pieces called packets.
 In real networks,
 these packets can arrive out of order,
 get lost along the way,
 or even show up more than once.
 To guarantee that everything is delivered correctly and nothing is missing,
 TCP uses two special kinds of numbers:
 sequence numbers and acknowledgment numbers.
 Sequence numbers work like this:
 every byte of data that gets sent is assigned its own unique number.
 When a packet is transmitted,
 its header contains the sequence number of the first byte of data inside that packet.
 Thanks to these numbers,
 the receiving side can put all the pieces of data back together in the right order,
 even if they arrive all jumbled up.
 If some piece is missing,
 the gap in the sequence numbers immediately reveals which part got lost,
 and the receiver can ask for it to be resent.
 Acknowledgment numbers serve another purpose:
 whenever the receiver gets new data,
 it sends back a message saying which byte it expects to receive next.
 This tells the sender that all bytes up to that number have already arrived safely,
 and that it’s time to send the next piece.
 If an acknowledgment isn’t received for a while,
 the sender knows that something went wrong and can retransmit the missing data.
 Here’s how it works in practice.
 When a connection is first established,
 both sides agree on which sequence numbers to start from.
 This happens using special flags in the TCP protocol called SYN and ACK (these are just flags to indicate the type of message,
 not actual sequence numbers themselves).
 After that,
 as data is transmitted,
 suppose the sender sends a packet with a sequence number of 1000 and includes 500 bytes of data.
 The receiver,
 upon getting these bytes,
 sends back an acknowledgment number of 1500.
 This means everything up to byte 1499 has been successfully received and the next byte expected should have the number 1500.
 If any of the data gets lost in transit and isn’t acknowledged,
 the sender will notice the missing acknowledgment and resend the necessary data.
 
\color magenta
[https://ru.stackoverflow.com/questions/566637/]
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP SYN 
\series default
\color inherit
bit is used during the very beginning of a TCP connection,
 in what’s called the “three-way handshake.” Its main purpose is to synchronize the sequence numbers between the two computers that want to communicate.
 Here’s how it works in practice:
 When one computer wants to establish a TCP connection with another,
 it sends a packet with the SYN flag set.
 This first SYN packet tells the receiver,
 “I want to start a conversation,
 and here is the initial sequence number I’d like to use.” This initial sequence number is important because it marks where the counting of bytes will begin for the data being sent.
 When the receiving computer gets this SYN packet,
 it replies with its own packet that has both the SYN and ACK flags set.
 This reply serves two purposes at once:
 First,
 it acknowledges that it received the first SYN by setting the ACK flag and including the expected next sequence number.
 Second,
 by also setting the SYN flag,
 it tells the initiator,
 “Okay,
 I’m ready too,
 and here’s the starting sequence number I want to use for my side of the communication.” Finally,
 the initiating computer sends one more ACK packet to confirm that it received the server’s response,
 and now both sides know which sequence numbers they’ll be using to track the conversation.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP reset bit,
 called the RST flag
\series default
\color inherit
,
 is used to immediately end a TCP connection or to reject an attempt to start one.
 When a packet arrives with the reset bit set,
 it tells the other side to instantly stop using that connection.
 This usually happens if one side receives unexpected data for a connection that doesn’t exist,
 or if a server receives a request on a closed port.
 For example,
 in security situations,
 if an attacker tries to connect to a protected or closed port,
 the server can respond with a TCP packet that has the RST flag set.
 This instantly tells the attacker that the connection is not allowed and to stop trying.
 Firewalls can also use the reset bit to automatically cut off suspicious or unauthorized connection attempts,
 making sure that attackers cannot find out which services are running.
 In this way,
 the reset bit helps quickly reject unwanted or suspicious connections and protects the server’s resources.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
TCP retransmissions
\series default
\color inherit
 happen when the data sent from one computer does not reach the other computer or is not confirmed as received.
 If the sender does not get a confirmation (an acknowledgment) after some time,
 it will send the same data again.
 This can happen if a packet is lost somewhere on the way or damaged.
 By resending the data,
 TCP makes sure that everything eventually arrives safely and in the right order,
 even if something goes wrong during transmission.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Flow control in TCP
\series default
\color inherit
 is a mechanism that prevents the sender from overwhelming the receiver with too much data at once.
 The main idea is that the sender might be able to send data much faster than the receiver can process or store it in its buffer.
 If this isn’t controlled,
 the receiver’s buffer could fill up,
 and some data might be lost.
 To avoid this problem,
 TCP uses a special field called the window size.
 This is a number that the receiver sends to the sender,
 telling it how many more bytes of data it is ready to accept at the moment.
 The sender is not allowed to send more data than what the current window size allows.
 Once the receiver has processed some of the data and has free space again,
 it sends an updated window size,
 and the sender can continue sending more data.
 For example,
 if the receiver is busy and its buffer is almost full,
 it can set the window size to zero.
 This tells the sender to stop sending new data until there is space again.
 When the receiver is ready,
 it increases the window size and informs the sender,
 which can then resume sending.
 In this way,
 flow control helps balance the speed between the sender and the receiver,
 prevents buffer overflow,
 and ensures that no data is lost just because one side is slower at handling the data.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP connection state LISTENING
\series default
\color inherit
 means that a server is waiting and ready to accept new incoming connections on a specific port.
 When a program (like a web server) wants to accept connections from clients,
 it creates a socket and puts it into the LISTENING state.
 In this state,
 the server is not yet connected to any client,
 but it is actively waiting for connection requests.
 As soon as a client tries to connect (by sending a SYN packet),
 the server can respond and begin establishing a new TCP connection.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP connection state ESTABLISHED
\series default
\color inherit
 means that a full two-way connection has been successfully set up between the client and the server,
 and both sides can now send and receive data.
 In this state,
 the three-way handshake is complete,
 and the connection is ready for actual data transfer.
 Any information sent by either side will be reliably delivered to the other side.
 Most of the time when two computers are actively communicating over TCP,
 their connection is in the ESTABLISHED state.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The source port
\series default
\color inherit
 is a number included in every TCP or UDP packet that identifies which application or process on the sender’s device sent the data.
 This allows the receiving device to know where replies should be sent,
 and it lets the sender’s own operating system deliver any response to the correct program when it comes back.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The destination port
\series default
\color inherit
 is a number in each TCP or UDP packet that specifies which application or service on the receiving device should get the incoming data.
 When a device receives a packet,
 it looks at the destination port to decide which program or service should handle that data.Source and destination ports together make sure that data flows between the correct applications on both sides,
 so replies return to the right sender,
 and new incoming data gets delivered to the right receiver.
\end_layout

\begin_layout Enumerate
Here are the common,
 well-known network services for those TCP ports:
\end_layout

\begin_deeper
\begin_layout Itemize
22:
 SSH (Secure Shell)
\end_layout

\begin_layout Itemize
23:
 Telnet
\end_layout

\begin_layout Itemize
25:
 SMTP (Simple Mail Transfer Protocol)
\end_layout

\begin_layout Itemize
80:
 HTTP (HyperText Transfer Protocol)
\end_layout

\begin_layout Itemize
443:
 HTTPS (HyperText Transfer Protocol Secure)
\end_layout

\begin_layout Itemize
3306:
 MySQL Database Service
\end_layout

\begin_layout Standard
These are standard assignments used across the internet,
 so when you see these port numbers,
 they usually mean the listed service is running on that port.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
A connection-oriented protocol 
\series default
\color inherit
like TCP is designed to make sure data gets from one computer to another safely and in the right order.
 With TCP,
 before sending any actual information,
 both sides set up a connection and agree on how communication will happen.
 This setup allows TCP to guarantee that all data will arrive,
 that the order of the data will be preserved,
 and that any missing or damaged information will be detected and resent automatically.
 TCP can also slow down or speed up data transfer depending on the state of the receiver and the network.
 That’s why TCP is used for things like web browsing and file transfers,
 where reliability is more important than speed.
 The combination of these features is what makes TCP a connection-oriented protocol:
 it’s all about managing and controlling the connection from start to finish to make sure nothing is lost or mixed up.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
A connectionless protocol
\series default
\color inherit
,
 like UDP,
 sends data without setting up any formal connection between the sender and receiver.
 With UDP,
 each packet is sent independently and there’s no guarantee that packets will arrive,
 arrive in order,
 or even arrive at all.
 There is no mechanism for checking errors,
 confirming delivery,
 or resending lost data.
 This lack of extra steps makes UDP fast and efficient,
 but also less reliable than TCP.
 UDP is called connectionless because it simply sends packets out,
 without any handshake or ongoing management of the connection,
 making it a good fit for applications where speed matters more than reliability like online games,
 voice calls,
 or live streaming.
\end_layout

\begin_layout Enumerate
Most services using UDP prefer to keep their datagrams at 512 bytes or less because this size can usually be sent across different networks without getting split into smaller fragments.
 If a UDP datagram is larger than 512 bytes,
 it might have to be fragmented into multiple pieces as it travels over the Internet.
 Fragmentation increases the chance that some pieces will get lost,
 and if even one fragment is missing,
 the entire datagram is lost.
 Keeping datagrams at 512 bytes or less makes transmission more reliable and avoids problems with fragmentation and loss,
 which is especially important since UDP itself doesn’t guarantee delivery or provide automatic retransmission.
 This size also matches traditional limits in protocols like DNS,
 which was originally designed to fit entirely within a single 512-byte UDP packet.
\end_layout

\begin_layout Enumerate
It is more reasonable to use UDP instead of TCP when speed is more important than reliability,
 or when your application can tolerate some data loss,
 out-of-order packets,
 or duplication.
 UDP is the better choice for real-time applications like online gaming,
 voice or video calls,
 and live streaming,
 where it’s more important to get data quickly than to guarantee every single packet arrives perfectly.
 UDP is also useful when sending small,
 simple queries like DNS requests,
 where adding the overhead of connection setup and error-checking would only slow things down.
\end_layout

\begin_layout Enumerate
What is the length of TCP header without extra options?
 What about UDP header?
\end_layout

\begin_deeper
\begin_layout Itemize
TCP Header (20 bytes,
 default fields,
 no options):
\end_layout

\begin_deeper
\begin_layout Itemize
Source Port (2 bytes)
\end_layout

\begin_layout Itemize
Destination Port (2 bytes)
\end_layout

\begin_layout Itemize
Sequence Number (4 bytes)
\end_layout

\begin_layout Itemize
Acknowledgment Number (4 bytes)
\end_layout

\begin_layout Itemize
Data Offset + Reserved + Flags (2 bytes)
\end_layout

\begin_layout Itemize
Window Size (2 bytes)
\end_layout

\begin_layout Itemize
Checksum (2 bytes)
\end_layout

\begin_layout Itemize
Urgent Pointer (2 bytes)
\end_layout

\end_deeper
\begin_layout Itemize
UDP Header (8 bytes):
\end_layout

\begin_deeper
\begin_layout Itemize
Source Port (2 bytes):
 The sender’s port number
\end_layout

\begin_layout Itemize
Destination Port (2 bytes):
 The receiver’s port number
\end_layout

\begin_layout Itemize
Length (2 bytes):
 The total length of the UDP packet (header + data)
\end_layout

\begin_layout Itemize
Checksum (2 bytes):
 Error-checking for header and data
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted15.png
	scale 30

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
\color brown
TCP Nagle’s algorithm 
\series default
\color inherit
is a feature designed to reduce the number of small packets sent over the network.
 When enabled,
 it collects small outgoing messages and sends them all together as one larger packet,
 instead of sending each tiny message separately.
 This helps reduce network congestion and overhead.
 However,
 Nagle’s algorithm can introduce delays in applications that need to send many small messages quickly,
 especially those that rely on real-time or interactive communication,
 like online games,
 VoIP,
 instant messaging,
 or trading platforms.
 In these cases,
 the small delays caused by waiting for more data to “bundle” can negatively impact responsiveness.
 Nagle’s algorithm should be disabled (using the TCP_NODELAY option) for networking applications that require minimal latency and instant delivery of small messages,
 such as real-time games,
 chat apps,
 or low-latency financial trading systems.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Maximum Transmission Unit (MTU)
\series default
\color inherit
 is the largest size,
 in bytes,
 of a single packet that can be sent over a particular network link without needing to be broken up.
 Every network interface (like Ethernet,
 WiFi,
 etc.) has its own MTU value,
 for example,
 standard Ethernet is usually 1500 bytes.
 If an IPv4 packet is larger than the MTU of the network,
 it must be split into smaller pieces—
this process is called fragmentation.
 Each fragment is sent as a separate packet,
 and at the destination,
 all fragments are reassembled into the original,
 full packet.
 Fragmentation is handled at the IP layer,
 not by TCP or UDP.
 Fragmentation is generally avoided if possible,
 because it increases the chance of packet loss (if one fragment is lost,
 the whole original packet is lost),
 and reassembly takes extra processing time.
 That’s why most applications try to keep packets within the MTU size of the network path.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
A raw socket 
\series default
\color inherit
is a special type of network socket that gives a program direct access to lower-level network protocols.
 Unlike regular sockets (like TCP or UDP),
 raw sockets allow the application to send and receive packets with custom headers,
 and even craft entire packets from scratch.
 Raw sockets are often used for network diagnostics,
 custom protocol implementation,
 packet sniffing,
 or security tools—
anything where you need full control over the packet structure (for example,
 writing your own ping,
 traceroute,
 or firewall).
 Because they bypass normal protocol handling,
 raw sockets usually require special privileges (like root/admin access) for security reasons,
 since they can be used for things like packet spoofing or attacks.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Port forwarding
\series default
\color inherit
 is a technique used in networking where incoming connections to a specific port on one device (usually a router or firewall) are automatically redirected to another port and/or another device inside the local network.
 This allows external users or services on the internet to access a computer or service (like a web server,
 game server,
 or CCTV camera) inside a private network,
 even though that device doesn’t have a direct public IP address.
 For example,
 if you set up port forwarding on your router for port 80,
 any connection coming to your home’s public IP address on port 80 will be sent directly to a specified computer inside your local network,
 also on port 80 (or any other port you choose).
 Port forwarding is commonly used for hosting servers at home,
 remote desktop access,
 gaming,
 and other scenarios where devices on a private network need to be reachable from the outside world.
\end_layout

\begin_layout Subsection

\color blue
Describe these protocols or services shortly:
 
\end_layout

\begin_layout Enumerate
IPSec
\end_layout

\begin_layout Enumerate
RTP and RTCP
\end_layout

\begin_layout Enumerate
QUIC (IETF)
\end_layout

\begin_layout Enumerate
Wireguard
\end_layout

\begin_layout Enumerate
DoH
\end_layout

\begin_layout Enumerate
Round-robin DNS
\end_layout

\begin_layout Enumerate
LDAP
\end_layout

\begin_layout Enumerate
Radius
\end_layout

\begin_layout Enumerate
Syslog
\end_layout

\begin_layout Enumerate
NTP
\end_layout

\begin_layout Enumerate
SNMP
\end_layout

\begin_layout Enumerate
SMTP
\end_layout

\begin_layout Enumerate
SMB/CIFS
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
IPSec
\series default
\color inherit
 is a set of protocols that keeps data safe when sending it over the internet between two devices or networks.
 The process starts with both sides deciding they want a secure connection,
 because regular IP packets can easily be intercepted or changed along the way.
 To set up this protection,
 both devices first need to agree on which encryption methods and keys they’ll use.
 They do this using the Internet Key Exchange (IKE) protocol,
 which lets them securely create a shared secret key,
 even though they’re talking over the open internet.
 Each side makes a public and a private value,
 exchanges the public part,
 and thanks to the math behind it (Diffie-Hellman),
 both can come up with the same secret key without anyone else figuring it out,
 even if someone is listening in.
 Now they both have matching keys and rules for how to protect the data,
 known as a security association.
 Once this is set up,
 IPSec steps in to protect the chosen traffic.
 Every time one side needs to send a packet,
 IPSec either encrypts it,
 signs it,
 or both depending on the agreed settings.
 It adds a special header for authentication (AH) or for encryption and authentication (ESP).
 In transport mode,
 only the data part of the packet is protected.
 In tunnel mode,
 the whole original packet gets wrapped up and hidden inside a new one,
 which is how VPNs usually work.
 The protected packet is then sent across the internet.
 When the other side receives it,
 it checks the signature,
 decrypts it if needed,
 and pulls out the original data before passing it along to the right app or network.
 This way,
 IPSec makes sure your data stays private and unchanged,
 even over public networks.
 That’s why it’s so widely used for VPNs and for safely connecting distant offices.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
RTP (Real-time Transport Protocol)
\series default
\color inherit
 is a protocol used to deliver audio and video over networks,
 like in video calls,
 online meetings,
 or IP telephony.
 When you’re in a voice or video chat,
 RTP is what actually moves the sound and video data between participants,
 making sure everything arrives quickly and in the right order for smooth playback.
 RTP doesn’t try to guarantee perfect delivery it’s designed for real-time use,
 so if a packet is late or missing,
 it just gets skipped (which is usually better than waiting and causing a lag).
 Each RTP packet has a sequence number and timestamp,
 so the receiver knows how to put everything back in order and sync up sound and video.
 Alongside RTP,
 there’s RTCP (RTP Control Protocol),
 which is like a helper protocol that travels alongside the main media stream.
 RTCP doesn’t carry actual media,
 but instead sends small control messages between the participants.
 These messages report things like packet loss,
 delay,
 or how well the connection is working.
 That way,
 applications (like Zoom,
 Skype,
 or any VoIP system) can monitor call quality in real time,
 adjust the stream if needed,
 and even show users stats like “poor connection.” Together,
 RTP and RTCP are the backbone for most live voice and video over the internet,
 balancing speed and quality to keep things smooth and responsive.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
QUIC
\series default
\color inherit
 is a transport protocol built on top of UDP and designed to improve the speed and security of internet connections compared to traditional protocols like TCP.
 When a client (like your browser) connects to a server using QUIC,
 it starts with a single handshake that establishes both the connection and the encryption keys,
 thanks to TLS 1.3 being integrated directly into QUIC itself.
 This handshake usually needs just one round trip,
 which means less waiting time before any real data starts to flow.QUIC uses unique connection IDs that stay the same even if your IP address changes,
 so you can move between networks (for example,
 switching from Wi-Fi to 4G) without losing your session.
 Inside one QUIC connection,
 you can have multiple independent streams of data,
 so if a packet is lost on one stream,
 it doesn’t hold up the others—
unlike TCP,
 where all streams can get blocked if anything goes missing (so-called head-of-line blocking).
 Each QUIC packet carries its own sequence number,
 and the protocol itself handles retransmissions and flow control for each stream separately.Another important detail is that QUIC encrypts not only the application data but also most of its own headers,
 making it harder to track or interfere with connections.
 All QUIC packets are sent over UDP,
 so they’re less likely to get stuck behind firewalls that throttle or filter TCP traffic.
 Because everything (from connection setup to encryption and retransmissions) happens within QUIC,
 it avoids delays from middleboxes,
 optimizes for speed,
 and adapts quickly to changing network conditions.
 Today,
 QUIC is the backbone of HTTP/3,
 which means modern browsers and major web services use it to make loading pages,
 streaming,
 and online communication much faster and smoother compared to the old web stack.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
WireGuard
\series default
\color inherit
 is a modern VPN protocol designed to be fast,
 simple,
 and highly secure.
 Unlike older VPNs like IPsec or OpenVPN,
 WireGuard is built around a minimal codebase and uses cutting-edge cryptography by default,
 such as Curve25519 for key exchange,
 ChaCha20 for encryption,
 and Poly1305 for authentication.
 When you set up a WireGuard tunnel,
 each device generates its own public and private key pair.
 To allow connections,
 you simply exchange public keys with the other side there’s no need for complex certificates or a certificate authority.
 Once configured,
 WireGuard sits at the network layer (Layer 3),
 creating a virtual network interface (like wg0) on your device.
 When you send data,
 it’s automatically encrypted using the peer’s public key,
 wrapped in a UDP packet,
 and sent to the remote endpoint.
 The other side decrypts it using its private key,
 checks the packet’s authenticity,
 and passes the data into its own virtual network.
 Because WireGuard is stateless in the traditional sense no sessions or handshakes after the initial key exchange packets can start flowing almost instantly,
 and connections recover quickly from drops or IP address changes.
 WireGuard uses a “silent by default” design:
 if there’s no traffic,
 it sends nothing,
 making it harder to detect or block.
 It also re-establishes handshakes automatically if network conditions change.
 The protocol is extremely lightweight just a few thousand lines of code which makes it easier to audit and secure compared to legacy VPN solutions.
 In practice,
 this means faster setup,
 lower CPU usage,
 and better performance for most use cases,
 whether you’re building a corporate VPN,
 connecting remote workers,
 or just protecting your data on public Wi-Fi.
 Because of its efficiency and simplicity,
 WireGuard is now built into the Linux kernel and widely available on most platforms.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
A DoH query
\series default
\color inherit
 (DNS over HTTPS query) is just a DNS request sent inside a secure,
 encrypted HTTPS connection instead of being sent as plain text.
 Normally,
 when your device wants to find the IP address for a website like youtube.com,
 it sends a DNS query in clear text to a DNS server.
 Anyone on the network (like your internet provider) can see or even change these plain DNS requests.
 With DoH,
 your device (usually your browser) wraps the DNS query inside an HTTPS request and sends it to a special DoH server,
 just like visiting a secure website.
 Because HTTPS is encrypted,
 nobody in the middle can see which websites you are looking up or interfere with your requests.
 The DoH server replies with the DNS answer,
 also over HTTPS,
 and your device then connects to the real website.
 In short,
 a DoH query is a DNS request hidden inside secure web traffic,
 protecting your privacy and preventing others from snooping on or tampering with the websites you visit.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Round-robin DNS
\series default
\color inherit
 is a simple technique used to distribute traffic across multiple servers by listing several IP addresses for the same domain name in the DNS records.
 When someone tries to visit a website,
 their device asks the DNS server for the IP address of the site.
 With round-robin DNS,
 the server replies with a list of several IP addresses each pointing to a different server that can handle the request.
 Every time a new DNS query comes in,
 the DNS server rotates the order of the IP addresses it returns.
 For example,
 if a domain has three servers,
 the first user might get IP1 first,
 the next user gets IP2 first,
 and so on.
 This way,
 users are spread out more evenly across all available servers,
 balancing the load and making the site more reliable.
 However,
 round-robin DNS is quite basic:
 it doesn’t check if a server is actually working before giving out its IP address,
 so sometimes users might get directed to a server that’s down.
 Still,
 it’s a popular and easy method to share traffic for big websites,
 gaming servers,
 or any service that needs simple load distribution.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
LDAP,
 or Lightweight Directory Access Protocol,

\series default
\color inherit
 is an application-level protocol that lets you access and manage a directory a special database storing information about users,
 computers,
 groups,
 and other resources in a company.
 It runs over TCP/IP,
 most often on port 389 or 636 for secure connections.
 Instead of each computer or service keeping its own list of users and passwords,
 LDAP provides a central place where everything is stored in a tree-like structure.
 When someone logs in to a computer,
 email,
 VPN,
 or other service,
 that system can check the user’s credentials directly with the LDAP server.
 This means you can set up one account for a person and use it everywhere across the organization,
 making things much simpler to manage.
 On the technical side,
 LDAP servers like Microsoft Active Directory or OpenLDAP let admins organize people and resources into branches and groups that reflect how the real company works.
 You can create rules about who can access what and update user details in one place.
 Computers whether Linux or Windows can be joined to the LDAP directory so users can log in with their company accounts,
 and their permissions or group memberships are automatically pulled from the directory.
 Because LDAP is an open standard,
 it works with a huge range of software and operating systems.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
RADIUS
\series default
\color inherit
 is a network protocol that’s mainly used to handle authentication,
 authorization,
 and accounting for users who connect to network services,
 such as Wi-Fi,
 VPNs,
 or remote access gateways.
 Instead of every router or access point keeping its own list of users and passwords,
 you set up a central RADIUS server where all user credentials and access rules are stored.
 When someone tries to connect,
 say,
 to a company’s Wi-Fi,
 the access point sends the user’s login details to the RADIUS server.
 The server checks the credentials often by comparing the username and password against a central directory like LDAP or Active Directory and then replies with a yes or no,
 and sometimes instructions on what the user is allowed to do.
 Besides authentication,
 RADIUS can enforce policies,
 such as which VLAN a user is assigned to,
 or limit connection times.
 It also tracks accounting data,
 like session duration or the amount of data transferred,
 which is helpful for auditing or billing.
 RADIUS typically uses UDP ports 1812 for authentication and 1813 for accounting.
 The protocol is very common in enterprise networks for controlling access to Wi-Fi,
 VPN,
 dial-up,
 and many other services.
 Its strength is that you get centralized control over who can log in and how,
 so you don’t have to manage passwords or permissions on every device separately.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Syslog
\series default
\color inherit
 is a standard protocol used for sending system logs and event messages across a network.
 It allows devices like servers,
 routers,
 switches,
 firewalls,
 and printers to report important events to a central log server,
 which makes monitoring and troubleshooting much easier.
 Each message typically includes information like the time,
 the source device,
 the type or severity of the event,
 and the actual log text.
 Syslog servers listen on UDP port 514 by default,
 though it can also use TCP.
 The protocol is simple and widely supported,
 so you can collect logs from all kinds of hardware and software in one place.
 This is essential for system administrators who want to keep track of what’s happening on their network,
 catch problems early,
 and analyze patterns or security incidents.
 Syslog messages can cover anything from user logins and errors to firewall alerts and application logs.
 With a central syslog server,
 you can store,
 search,
 and manage logs from hundreds of devices,
 which helps with auditing and daily operations.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
NTP,
 or Network Time Protocol
\series default
\color inherit
,
 is used to keep the clocks of computers and devices in sync across a network.
 Accurate time is much more important than it seems:
 it’s essential for keeping logs meaningful,
 making sure authentication works,
 coordinating distributed systems,
 and running scheduled tasks at the right moment.
 Without synchronized time,
 it becomes almost impossible to investigate incidents,
 compare events between servers,
 or run security protocols that rely on time stamps.
 Here’s how NTP works in practice.
 Each computer or server has its own internal clock,
 but these clocks naturally drift over time and can fall out of sync with each other.
 To fix this,
 an NTP client runs in the background and regularly contacts one or more NTP servers,
 which provide the precise current time,
 often sourced from atomic clocks or GPS.
 When your device reaches out,
 it sends a request including its own timestamp.
 The server responds with its own timestamps,
 and the client uses this information to calculate network delays and figure out the actual time difference between itself and the server.
 Instead of making sudden jumps,
 the client slowly and smoothly adjusts its own clock to line up with the accurate time.
 NTP works over UDP port 123,
 and usually there’s a hierarchy:
 company devices sync to a local NTP server,
 which in turn syncs with highly accurate external sources.
 This approach keeps all the clocks on your network closely matched.
 Thanks to NTP,
 logs stay meaningful,
 authentication protocols function properly,
 and automated tasks run when they’re supposed to.
 Reliable,
 synchronized time is a basic requirement for any modern IT infrastructure.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SNMP,
 or Simple Network Management Protocol
\series default
\color inherit
,
 is a standard protocol used to monitor and manage network devices like switches,
 routers,
 firewalls,
 printers,
 and servers.
 It lets network administrators collect information about the status and performance of devices,
 check for problems,
 and even make some remote changes if needed.
 Each device that supports SNMP runs a small piece of software called an SNMP agent,
 which keeps track of all sorts of statistics and settings like network traffic,
 CPU usage,
 memory,
 and interface status.
 From the administrator’s side,
 there’s usually an SNMP manager or monitoring system that regularly queries these agents,
 asking for data or getting automatic alerts if something goes wrong.
 The information is organized in a standardized way using something called a MIB (Management Information Base),
 so all the data is structured and easy to work with,
 even if it comes from different vendors.
 SNMP usually uses UDP ports 161 for queries and 162 for alerts,
 known as “traps.” Thanks to SNMP,
 admins can watch the health of their entire network in real time,
 automate responses to problems,
 and keep everything running smoothly from a single dashboard.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SMTP,
 or Simple Mail Transfer Protocol
\series default
\color inherit
,
 is the main protocol used to send email across the internet.
 When you send an email from your client like Outlook,
 Thunderbird,
 or a webmail service your message goes to an SMTP server,
 which then figures out how to deliver it to the recipient’s mail server.
 SMTP handles all the steps involved in relaying and forwarding mail from sender to receiver,
 making sure the message gets where it’s supposed to go.
 SMTP works over TCP,
 usually on port 25,
 465,
 or 587,
 and uses a straightforward text-based conversation between servers to deliver each message.
 It doesn’t deal with fetching or reading email from mailboxes that’s handled by other protocols like IMAP or POP3.
 SMTP is also responsible for handling issues like relaying,
 authentication,
 and spam prevention.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SMB,
 or Server Message Block
\series default
\color inherit
,
 is a protocol that lets computers share files,
 folders,
 and even printers with each other over a network.
 Imagine you have one computer with a folder full of documents,
 and you want other people in your office to be able to open,
 edit,
 or save files there without copying them back and forth on USB sticks.
 With SMB,
 you can “share” that folder,
 and everyone on the same network can access it right from their own computers,
 as if it was a local folder.
 The same works for printers:
 one printer can be connected to one computer but shared with the whole office so anyone can print.
 SMB is built into Windows and also works on Linux and macOS (for example,
 through Samba).
 It’s the reason you can see “Network Drives” or “Shared Folders” when you browse your company’s network.
 CIFS is just an older version of SMB,
 mostly used on older Windows systems,
 but nowadays people usually mean SMB when they talk about file sharing.
 This is different from remote desktop tools like AnyDesk or TeamViewer.
 With SMB,
 you don’t take control of someone else’s computer or see their screen.
 You’re just working directly with files and folders that live somewhere else on your network,
 without even noticing they’re not physically on your own machine.
 SMB is how companies make it easy for teams to collaborate,
 share documents,
 and use network printers,
 all without needing to physically connect to each device.
\end_layout

\begin_layout Subsection

\color blue
When listing services with netstat command,
 what is the meaning if some network service is LISTENING and binded to the IP address 127.0.0.1?
 What if the service is LISTENING IP address 0.0.0.0?
\end_layout

\begin_layout Standard
If a service is listening on 127.0.0.1,
 it means that service only accepts connections from the same computer (localhost).
 This is commonly used during development,
 when an application is not ready for public use and may have many vulnerabilities,
 so no other device on the network can connect to it only programs running on that machine can use it.
 This approach is typical for services that should not be exposed to the outside world,
 like a local database or a test web server.
 If a service is listening on 0.0.0.0,
 it means the service accepts connections on all network interfaces and IP addresses of the computer.
 This includes both local and remote connections,
 so other devices on the network (and potentially from the internet,
 if there’s no firewall) can reach the service.
 Using 0.0.0.0 is necessary when you want your application or service to be accessible by users or devices across your local network or even from outside,
 such as hosting a website,
 providing a shared resource,
 or running a server that should be reachable by multiple clients.
\end_layout

\begin_layout Subsection

\color blue
Why some applications are using or offer “keepalive” mechanism to maintain established connection (for example SSH connections)?
\end_layout

\begin_layout Standard
Some applications use a “keepalive” mechanism to make sure a network connection stays active and is not dropped by firewalls,
 routers,
 or NAT devices when there is no data being sent for a while.
 For example,
 with SSH connections,
 if you leave a terminal idle,
 many networks or devices will eventually close the connection,
 assuming it’s no longer needed.
 The keepalive mechanism solves this by sending small,
 regular packets over the connection,
 even when there’s no real data being transferred.
 These packets let both sides (and any devices in between) know that the connection is still alive,
 preventing unexpected disconnects due to inactivity.
\end_layout

\begin_layout Standard
To enable keepalive,
 you usually add specific settings in the program’s configuration.
 For SSH,
 you can set ServerAliveInterval and ServerAliveCountMax in your SSH client config file (~/.ssh/config) or ClientAliveInterval and ClientAliveCountMax in the SSH server config (/etc/ssh/sshd_config).
 These options control how often keepalive packets are sent and how many missed responses are allowed before closing the connection.
 If you don’t need keepalive,
 you can simply leave these options unset the connection will work,
 but may disconnect if left idle for too long,
 depending on your network.
\end_layout

\begin_layout Subsection

\color blue
Study available options with command line command “netstat /?” (Windows) or netstat –help (Linux,
 maybe MacOS).
 What different things you can check with netstat command?
\end_layout

\begin_layout Standard
With the netstat command,
 you can inspect many aspects of your system’s network activity.
 Based on the netstat --help output (see screenshot),
 you can:
\end_layout

\begin_layout Itemize
Display all active network connections and their states (connected,
 listening,
 etc.)
\end_layout

\begin_layout Itemize
Show which programs (processes) are using each network socket
\end_layout

\begin_layout Itemize
List all listening server sockets (services waiting for incoming connections)
\end_layout

\begin_layout Itemize
Display the routing table,
 showing how network traffic is directed
\end_layout

\begin_layout Itemize
View detailed statistics for each protocol (like TCP,
 UDP,
 ICMP,
 etc.)
\end_layout

\begin_layout Itemize
Show statistics and status for all network interfaces
\end_layout

\begin_layout Itemize
Check which multicast groups your interfaces have joined
\end_layout

\begin_layout Itemize
Show masqueraded (NAT) connections
\end_layout

\begin_layout Itemize
Display the forwarding information base or routing cache
\end_layout

\begin_layout Itemize
Customize the output to show numeric IPs,
 ports,
 or user names
\end_layout

\begin_layout Itemize
Continuously monitor changes with the -c option
\end_layout

\begin_layout Itemize
The help output also lists available options for working with different socket types (TCP,
 UDP,
 UNIX,
 etc.) and address families (IPv4,
 IPv6,
 etc.),
 so you can filter exactly what you need.
\end_layout

\begin_layout Standard
Below is a screenshot of the netstat --help output on my system:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted16.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Do the 50 ms mystery quiz from https://mysteries.wizardzines.com/.
 What was the cause of extra 50 ms delay?
\end_layout

\begin_layout Standard
The slowness is caused by the recvfrom system call taking a long time to return (about 40ms).
 This means the server is spending most of the time waiting to receive data from the client.
 Probably some problem with the internet connection or maybe I am using some slow protocol.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted17.png
	scale 30

\end_inset


\end_layout

\begin_layout Part*
Week #4
\end_layout

\begin_layout Subsection

\color blue
Use Croc to move file or files between two or more hosts/devices.
 Answer shortly:
\end_layout

\begin_layout Itemize

\color blue
How the Croc works?
\end_layout

\begin_layout Itemize

\color blue
How the Croc moves files if both hosts are not directly visible to each other?
 (for example,
 both are behind NATs or basic firewalls)
\end_layout

\begin_layout Standard
Croc is an open source command-line tool for sending files,
 folders,
 or text between two computers securely and conveniently even if both are behind NAT,
 firewalls,
 or on totally different networks.
 What sets Croc apart is its focus on end-to-end encryption,
 simple peer coordination,
 and its ability to work even in restrictive network conditions without user configuration.
 When you want to send a file with Croc,
 you start by running a command like croc send somefile.zip.
 The Croc client immediately generates a random,
 human-readable code (e.g.,
 bold-wolf-7).
 This code acts as both a rendezvous token (so both parties join the same session) and as the basis for cryptographic key exchange.
 You send this code to your recipient however you want by chat,
 phone,
 or in person.
 Both the sender and receiver clients connect to a public relay server (by default,
 croc.schollz.com:9009).
 This server's job is just to help the two parties find each other and exchange the minimal information needed to establish a direct connection.
 It’s not a storage server,
 and it never sees your files in plain text.
 Once both parties connect to the relay with the same code,
 they try to set up a peer-to-peer connection using a process called UDP hole punching.
 This lets two computers behind NAT routers try to establish direct contact by simultaneously sending UDP packets to each other's public IP and port as seen by the relay.
 If their routers support it (as most home routers do),
 a direct encrypted connection is made.
 If not,
 Croc transparently relays the traffic through the server,
 always keeping your data encrypted.
 Before any file is sent,
 Croc uses a cryptographic protocol called PAKE (specifically,
 SPAKE2) to derive a strong,
 session-specific encryption key from the shared code.
 The actual code is never sent over the network only cryptographic “blobs” that can’t be used to brute-force the key.
 All file data is then encrypted using AES-256-GCM (for confidentiality and authentication) before being sent over the wire,
 whether direct or through the relay.
 Files are chunked into pieces and transferred over QUIC (a modern UDP-based protocol) if possible,
 or TCP as a fallback.
 At the end,
 both parties compare file hashes to ensure integrity.
 In practice,
 this means that as long as you keep your session code secret,
 nobody can read your files not the relay server,
 not an attacker on the network,
 and not anyone who sees your encrypted packets.
 However,
 if someone learns your session code before the transfer,
 they could connect as a receiver and get the file,
 so you should treat the code as a sensitive secret and share it carefully.
 Croc doesn’t require opening ports,
 setting up accounts,
 or configuring firewalls.
 It works cross-platform and provides a real “just works” experience for sending sensitive files securely to anyone,
 anywhere even if they’re both behind restrictive networks.
\end_layout

\begin_layout Standard
Step 1.
 Install Croc on Both Machines:
\end_layout

\begin_layout Standard

\series bold
\color magenta
On Arch Linux (local):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted18.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color magenta
On Gentoo (remote):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted19.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Step 2.
 Prepare a test file to be sent on my local machine:
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted20.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
3.
 Sending And generating a secret code:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted21.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
4.
 I'v got some file bro:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted22.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
5.
 It works and I am happy.
 
\end_layout

\begin_layout Subsection

\color blue
Study how NTP protocol operates and analyse this Python NTP client code.
 Also available here as plain text.
\end_layout

\begin_layout Standard

\color blue
This Python script uses direct socket programming to access the NTP server.
 Comment individual socket programming related code lines.
 Also,
 answer these:
\end_layout

\begin_layout Enumerate

\color blue
What is the NTP server (DNS) hostname?
\end_layout

\begin_layout Enumerate

\color blue
What is the destination port number being used?
\end_layout

\begin_layout Enumerate

\color blue
Is this Python script using TCP or UDP?
 How do you know?
\end_layout

\begin_layout Enumerate

\color blue
Try to execute the app with Python
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted23.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
The NTP server sends back a 48-byte reply where the exact moment when the server sent its response is encoded in two fields:
 the 10th and 11th words of the packet (each word is 4 bytes).
 The 10th word contains the number of seconds since January 1,
 1900,
 and the 11th word gives the fractional part of that second as a 32-bit integer.
 To get the precise timestamp,
 the script combines these two values,
 adding the seconds and the fraction (divided by 2 to the power of 32),
 and then adjusts for the epoch difference between NTP and Unix time.
 This is how the script retrieves the accurate current time from the NTP server.
\end_layout

\begin_layout Subsection

\color blue
Do these Python programming assignments with Windows or Linux (or with MacOS if you want and know how)
\end_layout

\begin_layout Standard

\color blue
For example,
 use https://realpython.com/python-sockets/ or similar site(s) for socket programming example codes and create TCP client and TCP server Python scripts
\end_layout

\begin_layout Itemize

\color blue
Establish a TCP connection between your client and server Python scripts (either as localhost traffic or between two separate hosts if you have access to two or more Python running hosts without firewall preventing the traffic)
\end_layout

\begin_layout Itemize

\color blue
Transfer some ASCII text strings between the hosts
\end_layout

\begin_layout Itemize

\color blue
TCP client connects to the server,
 sends some plain text string and then disconnects
\end_layout

\begin_layout Itemize

\color blue
Server prints the text to the console or elsewhere
\end_layout

\begin_layout Itemize

\color blue
Save your source codes and work.
 You need scripts again during the course week #5 (Wireshark protocol analyzer assignments)
\end_layout

\begin_layout Itemize

\color blue
Use netstat or similar command line tools to check the TCP connection status (for example the Python server script LISTENING the selected TCP port)
\end_layout

\begin_layout Standard
1.
 I will use sshfs to be able to work with the file from GUI rather than using vim because I was brn in 1995 and not in 1975 though I like vim but not this time.
 This time I want to finish this exercise faster so I can go and drink some beer.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted24.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
2.
 I create remotely on the remote server using GUI the file 
\begin_inset Quotes eld
\end_inset

nothing_server.py
\begin_inset Quotes erd
\end_inset

 In the attached screenshot Yuo will fing the comments which explain what happens there.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted25.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
3.
 I create a client named 
\begin_inset Quotes eld
\end_inset

nothing_client.py
\begin_inset Quotes erd
\end_inset

 on my local machine in the same style:
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted26.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
4.
 I run the server on the remote host:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted27.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
5.
 I run the client and recieve a message from it on my Gentoo server:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted28.png
	scale 30

\end_inset


\begin_inset Graphics
	filename pasted29.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
6.
 I go to the bar and get some beer because I have a good mood now after all and wish you a good day or night too.
\end_layout

\end_body
\end_document
