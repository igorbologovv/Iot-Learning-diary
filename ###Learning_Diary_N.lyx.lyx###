#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008080
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Part*
Week #1
\end_layout

\begin_layout Subsection

\color blue
Define following terms and concepts shortly:
\end_layout

\begin_layout Enumerate
Network bandwidth
\end_layout

\begin_layout Enumerate
Network throughput
\end_layout

\begin_layout Enumerate
Packet loss and jitter
\end_layout

\begin_layout Enumerate
bps vs Bps
\end_layout

\begin_layout Enumerate
Protocol payload
\end_layout

\begin_layout Enumerate
Protocol overhead (especially for resource-contrained IoT purposes)
\end_layout

\begin_layout Enumerate
Spanning Tree Protocol
\end_layout

\begin_layout Enumerate
Collision domain
\end_layout

\begin_layout Enumerate
Broadcast domain
\end_layout

\begin_layout Enumerate
SOHO network
\end_layout

\begin_layout Enumerate
MAC (physical) address
\end_layout

\begin_layout Enumerate
Physical layer protocol data unit (PDU)
\end_layout

\begin_layout Enumerate
MAC layer protocol data unit (PDU)
\end_layout

\begin_layout Enumerate
Half-duplex vs Full-duplex
\end_layout

\begin_layout Enumerate
Ethernet auto-negotiation
\end_layout

\begin_layout Enumerate
Hidden node problem (wireless)
\end_layout

\begin_layout Enumerate
Networking physical vs logical topology
\end_layout

\begin_layout Enumerate
TIA/EIA-568 and ISO/IEC_11801
\end_layout

\begin_layout Enumerate
Ethernet cabling categories.
 For example,
 CAT 6
\end_layout

\begin_layout Enumerate
8P8C (RJ45)
\end_layout

\begin_layout Enumerate
Wifi AD HOC
\end_layout

\begin_layout Enumerate
IEEE 802.11ac,
 802.11ax,
 802.11be
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate
The definition of “
\series bold
\color brown
Bandwidth
\series default
\color inherit
” in the computing domain refers to the rate of data over time.
 Data is usually measured in bits,
 the time unit in seconds,
 and it’s often abbreviated as “bps”.
 This term is also used in lower-layer protocols,
 like the PHY layer in Wi-Fi,
 where bandwidth is measured in hertz (Hz),
 not in bps,
 but the wider the channel in Hz,
 the more bps can be transmitted.
 In Wi-Fi,
 it basically represents the channel width.
 Bandwidth refers to the maximum theoretical capacity of a channel to transmit data,
 it’s a property of the medium or communication channel,
 not the actual speed.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Throughput
\series default
\color inherit
,
 like bandwidth,
 also represents a rate of data over time,
 but unlike bandwidth where bps means the total theoretical capacity of the channel throughput measures the amount of bits delivered from source A to source B.
 In fact a data transmission can encounter different obstacles on the way,
 which can lead to packet loss or delays,
 that is why measuring throughput is critical in networking and signal processing.
 Data can be measured not only in bits,
 but also in packets or frames (blocks containing a fixed number of bits).
 
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Packet loss
\series default
\color inherit
 could be represented by formula:
 
\color red
PLR = (1 - (received frames) / (total frames transmitted))
\color inherit
 this shows the ratio of lost packets to total sent packets.
 The higher the result of this formula,
 the worse the channel quality.
 
\color brown
Jitter
\color inherit
 is a complex measurement and it can be calculated in different ways.
 For example,
 there are Random Jitter (RJ),
 Deterministic Jitter (DJ),
 and Total Jitter (TJ).
 Basically,
 jitter shows the variation in the packet delivery time in other words,
 how much the interval between packet arrivals changes over time the higher is a jitter value the less stable and predictable is a signal.
\end_layout

\begin_layout Enumerate

\series bold
\begin_inset Quotes eld
\end_inset


\color brown
bps
\series default
\color inherit

\begin_inset Quotes erd
\end_inset

 is an abbreviation for bits per second,
 while 
\begin_inset Quotes eld
\end_inset


\color brown
Bps
\color inherit

\begin_inset Quotes erd
\end_inset

 is bytes per second.
 
\color red
1 byte = 8 bits
\color inherit
.
 “Bps” is used in higher-layer protocols because data sizes are usually measured in bytes rather than bits.
 
\begin_inset Quotes eld
\end_inset

bps
\begin_inset Quotes erd
\end_inset

 is more useful in lower-layer protocols such as MAC or PHY.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Protocol payload
\color inherit
.

\series default
 Protocol in domain of computing is a set of rules which defines the way how to deliver and extract the message,
 without which it would be a random bit stream.
 
\color brown
Payload
\color inherit
 is an actual message,
 for which protocol is applied.
 
\series bold
\color brown
Message
\series default
\color inherit
 is a meaningful expression with well defined bounds (it has finite size) for example:
 
\family typewriter
\color darkgray

\begin_inset Quotes eld
\end_inset

I want to stop writing right now and go take some beer
\begin_inset Quotes erd
\end_inset


\family default
\color inherit
.
 
\color brown
Protocol payload
\color inherit
 is a message.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Protocol overhead
\series default
\color inherit
 is the extra cost,
 which can be represented as time,
 extra bits,
 and processing logic needed for delivering data from source to destination.
 For example,
 some protocol header bits must be sent with a message (payload) to ensure that the receiver can extract the message.
 It also could be some logic like a handshake in TCP to establish a connection between RX (receiver) and TX (transmitter).
 In the end,
 all of these things are time-consuming,
 that’s why they are called overheads.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Spanning Tree Protocol (STP)
\color inherit
,

\series default
 defined in IEEE 802.1D,
 is used to prevent loops in switched networks.
 Switches communicate with each other by sending BPDU (Bridge Protocol Data Units) every 2 seconds.
\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\shape italic
\begin_inset Quotes eld
\end_inset

I Think That I Shall Never See
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Graph More Lovely Than A Tree.
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Tree Whose Crucial Property
\end_layout

\begin_layout Standard

\family sans
\shape italic
Is Loop-free Connectivity.
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Tree That Must Be Sure To Span
\end_layout

\begin_layout Standard

\family sans
\shape italic
So Packets Can Reach Every LAN.
\end_layout

\begin_layout Standard

\family sans
\shape italic
First,
 The Root Must Be Selected.
\end_layout

\begin_layout Standard

\family sans
\shape italic
By ID,
 It Is Elected.
\end_layout

\begin_layout Standard

\family sans
\shape italic
Least Cost Paths From Root Are Traced.
\end_layout

\begin_layout Standard

\family sans
\shape italic
In The Tree,
 These Paths Are Placed.
\end_layout

\begin_layout Standard

\family sans
\shape italic
A Mesh Is Made By Folks Like Me,
\end_layout

\begin_layout Standard

\family sans
\shape italic
Then Bridges Find A Spanning Tree.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
At the start,
 all switches consider themselves as the root bridge and send BPDU messages containing their Bridge ID to neighboring switches.
 Each switch compares its own Bridge ID with the neighbor’s and forwards the smallest one further.
 After several exchanges,
 all switches know the Root Bridge,
 the switch with the lowest Bridge ID.
 Next,
 each switch calculates the shortest path to the Root Bridge using the path cost defined in 802.1D.
 If a switch has multiple paths,
 the shortest one is kept as the designated port,
 and the longer path is blocked.
 As a result,
 STP creates a loop-free spanning tree,
 ensuring that packets can reach every LAN segment while avoiding broadcast storms.
\end_layout

\end_deeper
\begin_layout Enumerate
A 
\series bold
\color brown
collision domain
\series default
\color inherit
 is a segment of a network space where a signal is traveling.
 To communicate,
 clients sometimes use the same route for example,
 the same frequency if we talk about Wi-Fi.
 When two clients try to send data at the same time on the same channel,
 their signals interfere and collide it will lead to packet loss.
 After a collision,
 the data must be retransmitted,
 which causes delays and reduces network performance.
\end_layout

\begin_layout Enumerate
A 
\series bold
\color brown
broadcast domain
\series default
\color inherit
 can be described as a segment of a network.If I send a frame on Layer 2 with the destination address FF:FF:FF:FF:FF:FF,
 it means “send this to all members of my subnet where I am located.”If the router is configured to combine several physical subnets into one logical subnet,
 then all of them become part of the same broadcast domain,
 even if they are physically separated.However,
 the actual boundary of such a broadcast domain will always end at the router,
 which separates this domain from the rest of the internet.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SOHO network 
\series default
\color inherit
(Small Office / Home Office) is not an official networking term,
 meaning it is not defined in any standards like IEEE 802.11.SOHO is used to describe a networking scenario,
 where several clients are connected through the same router or the same physical cable.In most cases,
 all clients are members of a single subnet,
 sharing the same LAN and belonging to the same broadcast domain.However,
 a SOHO network can also contain multiple broadcast domains for example,
 one subnet can be used for guests,
 another for IoT devices,
 and another for regular users.This separation is usually done using VLANs configured on the same router.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
MAC (physical)
\series default
\color inherit
 address is a unique number that every device with a network interface has,
 for example Wi\SpecialChar nobreakdash
Fi or Ethernet.
 It is usually 48 bits and written as hexadecimal pairs,
 for example AA:BB:CC:DD:EE:FF.
 MAC addresses are used on the Data Link Layer (Layer 2) so that devices can find each other inside the same network.
 When one device sends a frame to another,
 it puts its own MAC as the source and the MAC of the receiver as the destination.
 Without MAC addresses,
 sending data would be a lot more complicated,
 because devices would have to “ask” everyone in the network if the packet is for them.With MAC,
 it’s much easier —
 switches and Wi\SpecialChar nobreakdash
Fi routers know exactly where to deliver the frame.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Physical layer protocol 
\series default
\color inherit
data unit (PDU) is a bit.
 Generally,
 the physical layer does not have any high-level logic except for math and physics,
 where bits are turned into signals.
 In Wi-Fi these are radio waves,
 in Ethernet they are electrical signals,
 and in optical fiber they are light flashes.
 The exact instructions on how to modulate the signal come from Layer 2.
 The physical layer is usually optimized more by mathematicians and physicists than by programmers,
 but it's best when all three skills are combined in one person.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
MAC layer protocol data unit (PDU)
\series default
\color inherit
 is called a frame.
 Before sending data to the physical layer,
 L2 takes the IP packet from L3,
 adds the source and destination MAC addresses,
 and then the logic depends on the type of network.
 In modern Ethernet,
 which works in full-duplex,
 there’s no need for collision detection,
 so MAC mostly just adds the addresses and passes the frame down to the PHY layer.
 In Wi\SpecialChar nobreakdash
Fi,
 the MAC layer is a lot smarter:
 it has to analyze the channel,
 choose the right modulation for PHY,
 run algorithms to avoid collisions (CSMA/CA with random backoff),
 and only after all of this it sends the frame to L1 for transmission.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Half-duplex vs Full-duplex
\series default
\color inherit
.
 Half-duplex means a device can either transmit or receive,
 but not at the same time.
 Full-duplex means sending and receiving simultaneously.In modern Ethernet full-duplex is implemented on the physical level:
 the cable has separate pairs of wires for transmitting and receiving,
 so data flows both ways at once without collisions.
 In Wi-Fi,
 on the other hand,
 communication is half-duplex.
 A station cannot transmit and receive at the same time because its own signal would interfere with the receiver.
 Wi-Fi uses channel access algorithms and sometimes separates uplink and downlink subcarriers,
 but simultaneous full-duplex transmission is generally not used in current standards.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Ethernet auto-negotiation
\series default
\color inherit
 is a synchronization mechanism that allows two devices connected by an Ethernet cable automatically choose the best way to communicate.
 When devices are connected via cable,
 both start sending special signals called FLP (Fast Link Pulses),
 these signals contain information about what technologies each device has,
 like the supported speeds,
 duplex modes,
 and whether they support flow control.
 After exchanging this information,
 the devices compare their capabilities and pick the highest performance mode they both support.
 First,
 they choose the maximum possible speed,
 then they check the duplex mode:
 if both sides support full-duplex,
 they use it;
 otherwise,
 they fall back to half-duplex.
 Finally,
 they decide if flow control will be used which is a feature that helps to avoid packet loss when one side is slower than the other by 
\begin_inset Quotes eld
\end_inset

holding
\begin_inset Quotes erd
\end_inset

 data transmission.
 If auto-negotiation is disabled on one device but enabled on the other,
 the devices may choose different duplex modes,
 which leads to collisions,
 retransmissions,
 and lower performance.
 That’s why in most modern networks,
 auto-negotiation is enabled on both ends.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Hidden node problem
\series default
\color inherit
 (wireless) can occur when STAs (clients) are located far from each other but use the same AP (access point) between them.
 This is a MAC layer problem.
 In Wi\SpecialChar nobreakdash
Fi,
 all STAs share the same medium.
 When one STA sends data,
 it assumes the channel is free,
 but another STA may do the same,
 causing collisions and packet loss.
 To avoid this,
 the IEEE 802.11 standard includes the RTS/CTS (Request to Send / Clear to Send) mechanism:
 the device first sends RTS to the AP,
 and if the AP replies with CTS,
 other devices stay silent during the transmission.
 RTS/CTS is not always enabled because it adds overhead and is usually used when many clients are connected to the same AP.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Networking physical vs logical topology.

\series default
\color inherit
 
\series bold
\color brown
Physical topology
\series default
\color inherit
 is based on real devices like routers,
 switches,
 and bridges (older tech),
 linked via radio channels or physical cables.
 A simple example is a PC or several PCs connected to a switch via cables,
 and the switch connected to a router.
 Physical topology is a core part of networking,
 like a skeleton.
 There are several common types of physical topology,
 and some of them are outdated today:
 Star,
 Mesh,
 Ring,
 and Bus.
\end_layout

\begin_deeper
\begin_layout Itemize
Star topology is most common type today.
 Multiple devices are connected to the same central switch or hub.
 If one cable fails,
 the rest of the network keeps working.
 But if the central device fails,
 the entire network goes down.
\end_layout

\begin_layout Itemize
Mesh topology is modern and very reliable.
 Each device connects to several others,
 so there are multiple paths for data.
 If one link fails,
 traffic can be rerouted automatically.
 Full mesh (each device connected to all others) is rare because it’s expensive,
 so partial mesh is used more often.
 This idea is also used in Wi-Fi mesh networks to cover a large area without dead zones.
\end_layout

\begin_layout Itemize
Ring topology is when devices are connected in a circle,
 and data goes step by step through each node until it reaches the destination.
 Today,
 ring topologies are rare and mostly remain in some industrial or optical systems.
\end_layout

\begin_layout Itemize
Bus topology is one of the earliest types,
 where all devices share a single cable.
 Simple but depricated,
 replaced by switches and modern Ethernet.
\end_layout

\begin_layout Standard

\series bold
\color brown
Logical topology
\series default
\color inherit
 describes how data actually flows inside the network,
 regardless of how devices are physically connected.
 Even if multiple PCs are connected to the same physical switch (star topology),
 logically they can belong to different subnets or VLANs,
 which means they cannot communicate directly.
\end_layout

\end_deeper
\begin_layout Enumerate
TIA/EIA-568 and ISO/IEC_11801.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
\color brown
TIA/EIA-568
\series default
\color inherit
 is one of the main branches of the TIA standards,
 created by the Telecommunications Industry Association (TIA).
 It focuses on rules for structured cabling systems how to build Ethernet networks so that devices from different vendors work together.The standard defines cable categories like Cat5e,
 Cat6,
 Cat6a,
 and Cat8,
 each supporting different speeds and frequencies.
 It also describes how to wire and crimp RJ-45 connectors using two common schemes:
 T568A and T568B.
 Patch panels are also defined here,
 as well as maximum cable lengths and other installation rules.
 The main goal is to make sure network cables and equipment are compatible,
 reliable,
 and follow the same structured approach everywhere.
\end_layout

\begin_layout Itemize

\series bold
\color brown
ISO/IEC 11801
\series default
\color inherit
 is an international standard for structured cabling systems.
 It defines how to build universal cabling for offices,
 campuses,
 and other customer premises,
 so that different types of communication like Ethernet,
 telephony,
 and building control systems can work over the same infrastructure.This standard covers both twisted-pair copper cables and optical fiber.
 In many ways,
 it’s similar to TIA/EIA-568,
 but ISO/IEC 11801 is used globally,
 while TIA/EIA is mostly American.
 One important detail is that ISO includes Category 7 and 7a,
 but these are not recognized by TIA/EIA because there is no widespread hardware support for them.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
Ethernet cabling categories.

\series default
\color inherit
 For example,
 CAT 6.
 Cat6 is one of the most common Ethernet cables used today 
\shape italic
and backward compatible with the Category 5/5e and Category 3 cable standards
\shape default
 (From wikipedia) .
 It supports 1 Gbps up to 100 m and can handle 10 Gbps up to around 55 m,
 with a frequency of 250 MHz.
 The cable is widely used in offices,
 homes,
 small server rooms,
 IP cameras and VoIP systems,
 because it’s reliable,
 not too expensive,
 and still compatible with older equipment.
 In practice,
 Cat6 is a good balance between cost and performance,
 which is why it became the standard choice for most installations.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename cat6.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
8P8C (RJ-45)
\series default
\color inherit
 is the official name of the connector that people usually call RJ-45.
 The name means 8 Positions,
 8 Contacts,
 which describes the 8 pins inside the plug.
 This connector is used for Ethernet cables (Cat5e,
 Cat6,
 Cat6a,
 etc.) and lets devices like PCs,
 switches,
 and routers connect to each other.The term RJ-45 is technically not correct,
 because RJ-45 was originally a telephone standard,
 but in networking the name stuck and everyone uses it.
 In practice,
 when you say “RJ-45”,
 people understand it’s the standard Ethernet connector.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename rj45.png

\end_inset


\end_layout

\begin_layout Standard
21.
 
\series bold
\color brown
(IEEE 802.11ac,
 802.11ax,
 802.11be) 
\series default
\color inherit
These are different generations of the Wi\SpecialChar nobreakdash
Fi standard,
 each one improving speed,
 efficiency,
 and how many devices can work on the same network.
\end_layout

\begin_layout Itemize
802.11ac (Wi-Fi 5) works mostly on 5 GHz,
 supports channel widths up to 160 MHz,
 and gives speeds up to several Gbps.
 Introduced MU-MIMO,
 which lets multiple devices receive data in parallel instead of waiting one by one.
\end_layout

\begin_layout Itemize
802.11ax (Wi-Fi 6 / 6E) works on 2.4 GHz,
 5 GHz,
 and even 6 GHz (Wi\SpecialChar nobreakdash
Fi 6E).
 Improves MU-MIMO and adds OFDMA,
 splitting the channel into smaller sub-channels so more devices can transmit at the same time.
 Better performance in crowded environments and lower latency.
\end_layout

\begin_layout Itemize
802.11be (Wi-Fi 7) the newest generation.
 Uses channels up to 320 MHz wide and supports Multi-Link Operation (MLO) a device can use multiple frequency bands simultaneously for higher speeds and better stability.
 It also improves MU-MIMO even further,
 supporting up to 16 spatial streams and allowing many clients to send and receive data at the same time.
 Theoretical speeds can go above 40 Gbps.
\end_layout

\begin_layout Subsection

\color blue
Estimate how long does it take to download 3 TB file from cloud based backup service if network download throughput is 200 Mbps for actual payload (i.e.
 data)?
\end_layout

\begin_layout Itemize
Step 1 - Convert 3 TiB to bits (1 TiB = 1024⁴ bytes):
 
\begin_inset Formula $3\text{TiB}=3\times1024^{4}bytes=3.295\times10^{12}\text{bytes}\times8\text{byte}=2.636\times10^{13}\text{bits}$
\end_inset


\end_layout

\begin_layout Itemize
Step 2 - Divide by the payload throughput (200 Mbps):
 
\begin_inset Formula $T=\frac{2.636\times10^{13}bits}{200\times10^{6}\text{bits/s}}=1.318\times10^{5}s$
\end_inset


\end_layout

\begin_layout Itemize
Step 3 - Convert seconds to hours:
 
\begin_inset Formula $T_{\text{h}}=\frac{1.318\times10^{5}\text{s}}{3600s/h}\approx36.6h$
\end_inset


\end_layout

\begin_layout Standard
Answer:
 36.6 hours
\end_layout

\begin_layout Subsection

\color blue
Locate the MAC address of your mobile phone,
 laptop wifi interface or some other networked IT device
\end_layout

\begin_layout Standard

\color blue
How did you find it?
\end_layout

\begin_layout Standard

\color blue
List the MAC address in hex format (such as f0:1f:af:cf:d9:1a),
 but replace last 24 bits with zeros for your privacy
\end_layout

\begin_layout Standard

\color blue
Use OUI MAC address list(s) or lookup tools,
 and determine the device/chipset vendor of that MAC address.
 For example,
 that f0:1f:af:cf:d9:1a is Dell inc.
\end_layout

\begin_layout Standard
Device 1:
 Laptop (Arch Linux)
\end_layout

\begin_layout Standard
To find the MAC addr I used the ip link command in terminal.
 Wi-Fi interface is wlan0,
 its MAC address is shown next to link/ether.
\end_layout

\begin_layout Standard
MAC address:
\end_layout

\begin_layout Standard
6c:29:95:00:00:00 (last 24 bits zeroed for privacy)
\end_layout

\begin_layout Standard
Vendor (OUI lookup):
\end_layout

\begin_layout Standard
MAC prefix 6c:29:95 belongs to Intel Corporate
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted1.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
Device 2:
 Android smartphone
\end_layout

\begin_layout Standard
How did you find it?
\end_layout

\begin_layout Standard
Went to:
\end_layout

\begin_layout Standard
Settings → About phone → Status → Wi-Fi MAC address
\end_layout

\begin_layout Standard
MAC address:
 ac:c0:48:00:00:00 (last 24 bits zeroed for privacy)
\end_layout

\begin_layout Standard
Vendor (OUI lookup):
 AC:C0:48 OnePlus Technology (Shenzhen) Co.,
 Ltd.
\end_layout

\begin_layout Standard
(Looked up using the Wireshark OUI Lookup Tool
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted2.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Describe shortly what are these network devices,
 functions,
 and services
\end_layout

\begin_layout Enumerate
Repeater
\end_layout

\begin_layout Enumerate
Hub (multiport repeater)
\end_layout

\begin_layout Enumerate
Bridge
\end_layout

\begin_layout Enumerate
Access switch
\end_layout

\begin_layout Enumerate
Core switch
\end_layout

\begin_layout Enumerate
Edge router
\end_layout

\begin_layout Enumerate
Core router
\end_layout

\begin_layout Enumerate
Firewall
\end_layout

\begin_layout Enumerate
Wifi AP
\end_layout

\begin_layout Enumerate
WLAN AP controller
\end_layout

\begin_layout Enumerate
Network TAP
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
Repeater
\series default
\color inherit
 is a device used in networks or telecom lines to help signals travel longer distances.
 When a signal gets weak or noisy,
 the repeater picks it up,
 regenerates it,
 and sends it out again.
 This way,
 the signal can reach further without losing quality or becoming unreadable.
 Repeaters are used for Ethernet cables,
 fiber optic links,
 and even wireless connections.
 There are different types of repeaters depending on the technology,
 for example,
 telephone,
 optical,
 or radio repeaters.
 The main point is that a repeater doesn’t just make the signal louder.
 Repeater actually rebuilds the data and removes most of the noise,
 so errors don’t add up as the signal moves through the network.
 If the signal is already too weak or too noisy,
 a repeater might not help,
 but usually it keeps the data clear over long distances.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Hub
\series default
\color inherit
,
 or multiport repeater,
 is a simple network device used to connect several computers or other devices in a local network,
 usually with Ethernet cables.
 When a device sends data to the hub,
 the hub copies that data and sends it out to all its ports,
 so every connected device gets the same message,
 no matter who it was meant for.
 This is why hubs work at the physical layer (Layer 1) and don't know anything about addresses or who is supposed to get the data.Because hubs just repeat everything to everyone,
 they don’t help with traffic management if two devices send data at the same time,
 their signals will collide,
 which causes errors and forces the devices to resend their data.
 For this reason,
 hubs have been replaced by switches in most modern networks,
 since switches are smarter and only forward data to the right device,
 reducing collisions and making the network faster.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Bridge
\series default
\color inherit
 is a network device that splits a network segment into two parts to help filter traffic and cut down on unnecessary data.
 When data frames arrive,
 the bridge checks their MAC addresses to see if the sender and receiver are on the same side.
 If they are,
 the bridge blocks the traffic from crossing over.
 If they’re on different sides,
 the bridge lets the data through.
 This way,
 bridges help reduce collisions and keep local traffic separate,
 making the network more efficient.
 Bridges work at the data link layer (Layer 2).
 They’re especially useful for breaking up a large,
 busy network into smaller,
 quieter sections.
 In modern networks,
 simple bridges aren’t used much anymore because switches can do the same thing (and more),
 but the main idea is the same:
 bridges help organize network traffic and stop unnecessary signals from spreading everywhere.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Access switch
\series default
\color inherit
 is a network switch used to connect end devices,
 like computers,
 printers,
 or phones,
 to the local network.
 It’s usually placed at the edge of the network,
 close to users,
 and has many ports for plugging in devices with Ethernet cables.
 The main job of an access switch is to forward data only to the specific device it’s meant for,
 using MAC addresses—
which means,
 when one device sends data,
 the switch checks the destination MAC address and sends that data only to the right port,
 not to everyone else.
 This keeps traffic organized and reduces collisions.Access switches work at Layer 2 (the data link layer) and often support extra features,
 like VLANs for segmenting traffic,
 or Power over Ethernet (PoE) for powering devices directly through the cable.
 In most networks,
 access switches connect user devices to higher-level switches or routers,
 forming the first step for devices to access the rest of the network.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Core
\series default
\color inherit
 
\series bold
\color brown
switch
\series default
\color inherit
 is a high-performance network switch that is located at the center of a large network and connects multiple access switches together.
 Its main job is to move large amounts of data between different parts of the network,
 especially between different buildings or sections of an organization.
 Core switches usually have very high bandwidth and fast processing to handle lots of simultaneous connections.
 Unlike access switches,
 core switches don’t connect directly to end devices like computers or printers they mostly connect to other switches and routers.
 They work at Layer 2 or sometimes Layer 3 (data link),
 and are designed for speed and reliability,
 making sure data can always get from one side of the network to the other.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Edge router 
\series default
\color inherit
is a network device (Layer 3) that sits at the boundary between an internal network (like a company or campus LAN) and an external network,
 usually the internet or another organization’s network.
 Its main job is to route traffic in and out of the local network,
 deciding which data goes where based on IP addresses.
 Edge routers also often handle things like NAT (Network Address Translation),
 firewall rules,
 VPNs,
 and sometimes basic security functions,
 protecting the internal network from outside threats.In short,
 the edge router acts as the main gateway between your private network and the outside world.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Core router
\series default
\color inherit
 is a high-capacity network device (Layer 3) located in the center of large networks,
 such as service provider backbones or big enterprise networks.
 Its main job is to quickly route large amounts of data between different parts of the network,
 connecting multiple edge routers and distribution switches.
 Core routers are optimized for speed,
 reliability,
 and handling high volumes of traffic,
 but they usually don’t connect directly to end devices.
 In summary,
 a core router forms the backbone of a big network,
 moving data efficiently between major segments.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Ffirewall
\series default
\color inherit
 is a security device or software that controls which data is allowed to enter or leave a network or a single computer based on a set of rules.
 Its main job is to block unwanted or dangerous traffic.
 Firewalls can be physical devices placed between networks,
 or software running on a computer or server.
 Firewalls check network packets for things like source and destination addresses,
 ports,
 and protocols.
 Based on this information,
 the firewall decides whether to allow or block the traffic.
 This helps protect networks from attacks,
 unauthorized access,
 and malware.
 In most modern networks,
 firewalls are used to separate private internal networks from the public internet,
 adding an important layer of defense.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
WiFi access point (AP)
\series default
\color inherit
 is a device that allows wireless devices,
 like laptops and smartphones,
 to connect to a wired network using Wi-Fi.
 The AP acts as a bridge between the wireless devices and the wired part of the network (for example,
 an Ethernet LAN).
 When you connect your phone or laptop to Wi-Fi,
 you’re actually connecting to the access point,
 which then forwards your data to the rest of the network.
 Wi-Fi APs handle radio communication,
 manage which devices can connect,
 and take care of basic security settings like passwords and encryption.
 In home networks,
 the AP is often built into the Wi-Fi router,
 but in bigger networks (like offices or schools),
 there are usually several standalone APs placed around the building to give good wireless coverage everywhere.In short,
 a Wi-Fi AP is what lets wireless devices join the local network and get access to the internet or other resources.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Wireless LAN controller (WLC)
\series default
\color inherit
 is a device or software that centrally manages multiple WiFi access points in large networks,
 like offices or campuses.
 Instead of configuring each access point separately,
 admins use the controller to set WiFi settings (such as passwords,
 network names,
 and firewall rules) once,
 and the changes apply to all APs automatically.
 The WLC also manages security,
 firmware updates,
 and load balancing across access points.
 Another key function is seamless roaming:
 as users move through the building,
 their devices can automatically switch between access points without losing connection,
 because the controller coordinates the 
\color violet
handover
\color inherit
 process.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Network TAP (Test Access Point)
\series default
\color inherit
 is a hardware device that’s used to monitor and capture network traffic for analysis.
 It sits between two points in the network and makes an exact copy of all the data passing through,
 sending it to a monitoring or security tool.
 Unlike a switch port in mirror mode,
 a TAP is a dedicated device,
 so it captures traffic without interfering or slowing down the network.Network TAPs are commonly used for network troubleshooting,
 security monitoring,
 or recording traffic for later analysis.
 They work at Layer 1 (physical layer) and are often used in data centers or anywhere reliable,
 passive network monitoring is needed.
\end_layout

\begin_layout Subsection

\color blue
RFC assignments
\end_layout

\begin_layout Enumerate
What are RFCs?
\end_layout

\begin_layout Enumerate
How many PPP related RFC documents can you find from rfc-editor website?
\end_layout

\begin_layout Enumerate
What is the current status of RFC1597?
 What is the number for updated,
 more recent RFC of same topic?
\end_layout

\begin_layout Enumerate
When was RFC5218 released?
\end_layout

\begin_layout Enumerate
What is the meaning if RFC status is BCP?
\end_layout

\begin_layout Enumerate
List authors of the CoAP RFC (June 2014).
 What is the RFC number?
\end_layout

\begin_layout Enumerate
Twitch.tv provides IRC access to the stream chats.
 Which RFC defines the original Internet Relay Chat (IRC) Protocol?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
An RFC (Request for Comments)
\series default
\color inherit
 is kind of like open-source documentation for how the internet works.
 Anyone engineers,
 researchers,
 or even just enthusiasts can write and submit an RFC if they have an idea or proposal about how something on the internet should work.
 The process is similar to making a pull request for code,
 but instead of merging changes,
 your RFC is published as its own document with a unique number if it gets accepted.
 Other experts can review,
 discuss,
 and suggest edits just like code review in open-source projects.
 If something needs to be changed later,
 a new RFC is created instead of editing the old one.
 All the discussions and documents are open and public.
 RFCs cover everything from technical standards (like TCP/IP,
 HTTP,
 DNS,
 email),
 to experiments,
 to even jokes.
 Some RFCs become official internet standards after enough review and consensus,
 but many are just for sharing information or starting a conversation in the community
\end_layout

\begin_layout Enumerate

\series bold
\color brown
How many PPP related RFC documents can you find from rfc-editor website?

\series default
 
\color inherit
According to the rfc-editor.org which i checked.
 I fount 111 RFC documents related to PPP (Point-to-Point Protocol).
 I used Title/Keyword search and got this:
 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted3.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
What is the current status of RFC1597?
 What is the number for updated,
 more recent RFC of same topic?
 The current status of RFC1597 is Informational (it’s not an official standard,
 just a technical note).RFC1597 has been obsoleted by RFC1918,
 which is the updated and more widely used document on the same topic (private IP address ranges for IPv4).So,
 RFC1918 is the newer and active RFC covering this topic.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Graphics
	filename rfs1597.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard

\color brown
\begin_inset Graphics
	filename obsolated.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
When was RFC5218 released?

\series default
\color inherit
 Even though the timeline on the page shows November 2007,
 that’s just when the draft work started and the document was first discussed.
 The actual RFC was published later—
look at the “Type” line,
 which says “RFC - Informational (July 2008)”.For any report or official answer,
 you always use the publication date of the RFC itself,
 not the draft or discussion dates.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename RELEASERFC.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
BCP stands for Best Current Practice.

\series default
\color inherit
 If an RFC has the status BCP,
 it means it describes the best way to do something on the internet right now sort of like an official recommendation or guideline,
 but not a strict standard.
 BCPs are used for things that everyone should probably follow,
 but that might change over time as technology and best practices evolve.
 So,
 BCP = Best Current Practice = recommended way to do things at the moment,
 not a permanent standard.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
List authors of the CoAP RFC (June 2014).
 What is the RFC number?
 
\color violet
Authors:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
\color violet
Z.
 Shelby
\end_layout

\begin_layout Itemize

\series bold
\color violet
K.
 Hartke
\end_layout

\begin_layout Itemize

\series bold
\color violet
C.
 Bormann
\end_layout

\begin_deeper
\begin_layout Itemize
And the RFC number is RFC 7252.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename rfcauthors.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
Twitch.tv provides IRC access to the stream chats.
 Which RFC defines the original Internet Relay Chat (IRC) Protocol?
 
\series default
\color inherit
The answer is RFC 1459.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename IRC.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection

\color blue
What is OSI model?
 Compare OSI model to TCP/IP model
\end_layout

\begin_layout Standard

\color brown
The OSI (Open Systems Interconnection model)
\color inherit
 is a way to describe how network communication works by splitting everything into seven clear layers,
 each with its own job.
 It was created by ISO (International Organization for Standardization) in the 1980s,
 mostly to help different vendors’ equipment and software work together,
 and to give people a common language for talking about networks.
 Example:
 Sending an email (OSI pipeline) 
\end_layout

\begin_layout Itemize
Application layer :
 You write your message and hit “send” in your email app.
 The app uses a protocol like SMTP (Simple Mail Transfer Protocol) to format and send your message.
\end_layout

\begin_layout Itemize
Presentation layer:
 If your message uses special characters,
 emojis,
 or attachments,
 this layer makes sure the data is properly encoded (for example,
 turning your message into ASCII or UTF-8).
 If you’re using encryption (like TLS/SSL),
 this layer encrypts your email so only the right recipient can read it.
\end_layout

\begin_layout Itemize
Session layer:
 Your app opens a “session” or connection to your email server—
basically,
 it handles logging in,
 keeping the connection alive while your email is sent,
 and closing it when finished.
\end_layout

\begin_layout Itemize
Transport layer:
 This layer breaks your email into smaller pieces (“segments” or “packets”) and ensures they all get to the server reliably and in the right order.
 It uses protocols like TCP (Transmission Control Protocol) to handle lost packets or errors.
\end_layout

\begin_layout Itemize
Network layer:
 The system adds your and the server’s IP addresses to each packet.
 This layer figures out the best path for each packet to travel across the internet from your device to the destination.
\end_layout

\begin_layout Itemize
Data Link layer:
 Each packet gets wrapped in a “frame” with information like MAC addresses,
 so devices on your local network (like your router or Wi-Fi access point) know where to send it next.
\end_layout

\begin_layout Itemize
Physical layer:
 Finally,
 the data gets turned into electrical signals (if you’re on Ethernet),
 radio waves (if you’re on Wi-Fi),
 or pulses of light (if you’re on fiber).
 The signals travel through cables or wirelessly to the next device,
 starting their journey through the network.
\end_layout

\begin_layout Standard
The OSI model breaks everything into seven layers,
 but real-world networks including the whole Internet actually use the TCP/IP model,
 which has just four layers.
 In TCP/IP,
 some of the OSI layers are combined to keep things simple
\end_layout

\begin_layout Itemize
Link (covers OSI’s Physical and Data Link)
\end_layout

\begin_layout Itemize
Internet (same as OSI’s Network)
\end_layout

\begin_layout Itemize
Transport (same as OSI’s Transport)
\end_layout

\begin_layout Itemize
Application (combines OSI’s Session,
 Presentation,
 and Application)
\end_layout

\begin_layout Standard
The reason the TCP/IP model combines some of the OSI layers is because,
 in real life,
 there’s usually no need for separate “Session” or “Presentation” layers.
 Things like data formatting,
 encryption,
 and session management are almost always handled by the application itself or by libraries and protocols that sit at the Application layer.
 There aren’t special,
 separate protocols just for these jobs everything is built into how the application works.
 So,
 there was no point in keeping those layers separate.
 Fewer layers means less complexity,
 less overhead,
 and it’s easier for engineers to actually design and troubleshoot real networks.
 That’s why the TCP/IP model is simpler and lines up better with how the internet actually runs.
\end_layout

\begin_layout Part*
Week #2
\end_layout

\begin_layout Subsection

\color blue
What are VLANs and IEEE 802.1q?
\end_layout

\begin_layout Standard

\series bold
\color brown
VLAN (Virtual LAN)
\series default
\color inherit
 is a technology that splits one physical network into multiple logical networks.
 Normally,
 a switch without VLANs is one big broadcast domain:
 every device can hear every broadcast and send data to everyone else.
 VLANs break this domain into smaller,
 isolated ones.
 Devices in different VLANs cannot directly see each other’s traffic,
 even if they are connected to the same physical switch.
 This improves security,
 reduces unnecessary traffic,
 and keeps networks easier to manage.
 On a switch,
 VLANs are configured per port:
\end_layout

\begin_layout Itemize

\color violet
Access
\color inherit
 ports connect end devices (like PCs,
 printers,
 or phones).
 Each access port belongs to exactly one VLAN,
 and the device doesn’t need to know about VLANs —
 the switch automatically assigns all traffic from that port to the correct VLAN.
\end_layout

\begin_layout Itemize

\color violet
Trunk
\color inherit
 ports connect switches to each other,
 or a switch to a router or firewall.
 A trunk must carry traffic from multiple VLANs over a single cable.
\end_layout

\begin_layout Standard
To keep packets separated on a trunk,
 the
\series bold
\color brown
 IEEE 802.1Q standard
\series default
\color inherit
 is used.
 It adds a small VLAN tag into the Ethernet frame,
 containing the VLAN ID.
 When another switch receives the frame,
 it reads the tag and knows exactly which VLAN that packet belongs to.
 This allows VLAN 10,
 VLAN 20,
 and VLAN 30 to all share the same trunk link without getting mixed up.
 The advantage of this setup is centralized control:
 all VLANs can be delivered to one core switch,
 router,
 or firewall,
 where the administrator decides the rules which VLANs can talk to each other,
 which can only access the internet,
 and which are completely isolated.
 Without VLANs and trunking,
 you would need separate physical switches and cables for every network segment,
 which is costly and harder to manage.
\end_layout

\begin_layout Subsection

\color blue
Define following terms and concepts shortly:
\end_layout

\begin_layout Enumerate
ARP
\end_layout

\begin_layout Enumerate
ARP spoofing
\end_layout

\begin_layout Enumerate
HOP (networking)
\end_layout

\begin_layout Enumerate
IP TTL
\end_layout

\begin_layout Enumerate
IP TOS (DSCP)
\end_layout

\begin_layout Enumerate
DHCP,
 DHCP relay
\end_layout

\begin_layout Enumerate
WoL (Wake-on-LAN)
\end_layout

\begin_layout Enumerate
UPnP
\end_layout

\begin_layout Enumerate
Traceroute / Tracepath
\end_layout

\begin_layout Enumerate
Network Address Translation (NAT)
\end_layout

\begin_layout Enumerate
Tier 1 and 2 networks
\end_layout

\begin_layout Enumerate
Tier 3 ISP
\end_layout

\begin_layout Enumerate
Routing Autonomous System (AS or ASN for BGP)
\end_layout

\begin_layout Enumerate
127.0.0.1 address
\end_layout

\begin_layout Enumerate
::1 address
\end_layout

\begin_layout Enumerate
0.0.0.0/0 and ::/0 networks in the routing table
\end_layout

\begin_layout Enumerate
Ranges of IPv4 multicast and experimental addresses
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
ARP
\series default
\color inherit
 stands for Address Resolution Protocol.
 It was created in 1982 by David Plummer at MIT and described in RFC 826.
 The idea behind ARP is simple computers need to talk to each other over a network,
 and for that they use IP addresses.
 But on a physical level,
 like Ethernet or Wi-Fi,
 they actually send data to MAC addresses.
 So when a computer wants to send a packet to some IP like 192.168.1.1,
 it first needs to figure out what MAC address is linked to that IP.
 ARP does exactly that.
 It sends a broadcast message to the local network asking “who has this IP?”,
 and the device that owns that IP replies with its MAC.
 The computer then saves that info in its ARP table and uses it to send data directly.
 This is how communication works in IPv4 networks.
 In IPv6,
 ARP is replaced with a different protocol called Neighbor Discovery.
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
ARP spoofing 
\series default
\color inherit
is when someone on the same local network pretends to be another device by sending fake ARP replies.
 Imagine you're connected to Wi-Fi and your computer asks "who has IP 192.168.1.1?" because it wants to talk to the router.
 The router replies with its real MAC address,
 but at the same time there's some guy nearby – let's call him Vasyan in dark sunglasses – and he also replies,
 saying that he is 192.168.1.1 and gives his own MAC address.
 Your computer just takes the last answer it gets and saves it in its ARP table.
 It doesn’t check who is telling the truth.
 Now all your traffic goes to Vasyan instead of the real router.
 He can read it,
 change it,
 or block it.This works because ARP is an old and dumb protocol.
 It accepts whatever answer comes,
 and always updates the ARP table with the latest reply.
 That’s why ARP spoofing is so easy to do – you just keep sending fake ARP replies every few seconds and you stay in control.To defend against this,
 people use static ARP entries,
 special tools that detect spoofing,
 or move to IPv6 where the system works differently and has more protection.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
HOP (networking)
\color inherit
.
 
\family sans
\series default
\shape italic
In networking,
 a hop is one step that a packet makes as it travels from one device to another.
 Every time it moves from one router or node to the next,
 that’s a hop.
 It’s like checkpoints on the way from sender to receiver.
 You can actually trace them using tools like traceroute,
 which shows how many hops your packet needs to reach a target.
 The more hops,
 the more delay and risk of packet loss.In IP networks,
 hops are limited by a field called TTL time to live.
 Each hop decreases the TTL by 1.
 If it reaches zero,
 the packet is dropped.
 This prevents endless loops in the network.To understand hops better,
 I wrote a small C++ simulation that models message propagation across a network of 10 000 nodes.
 Each node randomly picks 3 other nodes to send a message to (fanout = 3).
 I start with a single "mother node" and simulate how the message spreads across the network,
 counting how many hops it takes to reach each node.
 Every node keeps track of how many times it got the message and at what hop it arrived.
 This way,
 I can measure not just average hop count,
 but also how many duplicate messages appear,
 how many nodes were reached,
 and how much total traffic was generated.The simulation uses a custom stack-based message queue instead of dynamic containers like std::vector,
 to avoid heap allocation overhead.
 It runs multiple iterations and averages out the results.
 The final stats include average number of hops per reached node,
 total number of messages sent,
 and how much redundancy was created in the process.This model helped me get an intuitive feel for how information propagates in large random graphs,
 how fanout affects reachability,
 and what the typical hop distance is.
 It also ties back nicely to the concept of hops in real-world networking —
 the more intermediate points,
 the longer the path,
 and the more chances for noise or duplication.
 GitHub link to the code:
 
\series bold
\color violet
(https://github.com/igorbologovv/10KNodes/blob/main/node_jump.cpp)
\end_layout

\begin_layout Enumerate

\series bold
\color brown
TTL
\series default
\color inherit
 stands for Time To Live.
 Despite the name,
 it’s just a number inside an IP packet that limits how many hops the packet can make.
 Each time it passes through a router,
 TTL goes down by 1.
 When it hits zero,
 the packet is dropped.This prevents endless loops if routers misbehave.
 Without TTL,
 broken routing could flood the network.
 Tools like traceroute use TTL to map paths by sending packets with increasing TTL values and seeing where they get stopped.Different systems use different starting TTLs Linux might start at 64,
 Windows at 128,
 some devices use 255.
 So TTL can also help identify operating systems.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
TOS
\series default
\color inherit
 stands for Type of Service it’s a field in the IP header that was meant to tell the network how a packet should be treated.
 Over time,
 the old TOS system was replaced with DSCP,
 which stands for Differentiated Services Code Point.
 DSCP gives us 6 bits in the IP header to mark the priority of traffic basically,
 a way for the packet to say:
 “hey,
 I’m important” or “I can wait”.
 This is mostly used for Quality of Service (QoS).
 Routers and switches can read these DSCP values and decide how to queue or forward the packets.
 For example,
 voice packets (like from a Zoom call or VoIP app) are usually marked with DSCP 46 that means “low delay,
 treat me fast”.
 These packets are small,
 sensitive to delay,
 and can’t be buffered.
 Video calls might get DSCP 34 also high-priority,
 but not as strict as voice.
 On the other hand,
 file downloads or software updates are marked as best effort,
 which just means:
 “deliver me whenever”.And even chat messages over UDP might get their own DSCP level not as urgent as voice,
 but still more important than background traffic.
 This is especially useful when the network is under load.
 The whole idea is to make sure real-time stuff gets through first.
 Now,
 DSCP is not just for UDP.
 It works with all IP traffic UDP,
 TCP,
 ICMP,
 even encrypted VPN tunnels.
 The reason people often talk about UDP in this context is because it’s usually used for real-time traffic,
 where delays and packet loss really hurt.
 TCP traffic (like web browsing or file transfer) can also use DSCP,
 especially in finance or other systems that care about latency or reliability.
 But since TCP already has its own built-in mechanisms like retransmissions and congestion control DSCP has less impact there.So yeah,
 any packet can carry a DSCP value,
 but whether the network honors it depends on router configuration.
 In home networks,
 DSCP might be ignored.
 In corporate or ISP environments with QoS policies it matters a lot.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
DHCP (Dynamic Host Configuration Protocol)
\series default
\color inherit
 is a protocol that automatically assigns IP addresses,
 gateway,
 DNS,
 and other settings to devices when they join a network.
 In home networks,
 the router usually acts as the DHCP server,
 handing out private IPs from a preset range and keeping track of who got what.
 The router itself gets a public IP from the ISP via DHCP and uses NAT to let all local devices share that one public IP,
 tracking connections with a NAT table.
 
\series bold
\color brown
DHCP relay
\series default
\color inherit
 is used when the DHCP server is in a different subnet.
 The relay agent (usually a router or switch) forwards the client’s broadcast request to the real server and relays the response back,
 allowing centralized IP management in larger networks.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Wake-on-LAN (WoL)
\series default
\color inherit
 is a feature that lets you remotely turn on a computer over the local network by sending it a special packet called a magic packet.
 This packet contains the target device’s MAC address repeated several times,
 and it’s usually sent as a broadcast to the whole LAN.
 For WoL to work,
 the computer must support it at the hardware level (typically in the NIC and BIOS/UEFI),
 and it has to be in a low-power state,
 not completely shut off.
 The NIC listens passively on the network,
 and when it sees its MAC repeated in a magic packet,
 it triggers the system to power on.
 WoL doesn’t work over the internet directly,
 unless you set up port forwarding or VPN.
 It’s mainly used in local networks to wake up machines for remote access,
 updates,
 or maintenance.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
UPnP (Universal Plug and Play)
\series default
\color inherit
 lets devices on your local network automatically open ports on the router to make themselves accessible from the internet.This is useful because routers with NAT block all incoming connections by default,
 unless the user manually sets up port forwarding.With UPnP enabled,
 an app can request the router to open a specific port and forward any traffic from the internet to that device.This is used by games,
 torrent clients,
 or remote access tools so they can accept incoming connections without manual setup.The downside is security:
 any device in your local network can expose itself to the internet,
 which can be dangerous if malware is present.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Traceroute / Tracepath.

\series default
\color inherit
 When you're checking network problems,
 you usually start with ping it just tells you if the connection works.
 But if you want to know how the packets travel to the destination,
 you use traceroute or tracepath.
 Tracerout is the classic tool,
 it can send packets using UDP,
 TCP or ICMP,
 and works with both IPv4 and IPv6,
 it shows you every hop (router) between your device and the destination,
 and for each one,
 it prints 3 round-trip times (RTTs).
 You can even tweak the way packets are sent.
 But to do that,
 traceroute often needs root access because crafting custom or raw packets can be a security risk.
 Tracepath is the simpler and safer tool.
 It uses normal UDP packets and doesn’t need root.
 It can’t do advanced tricks,
 but it’s great for basic diagnostics,
 it shows similar output:
 each hop,
 its IP or hostname,
 and the round-trip time (but only once per hop).It also shows the MTU (maximum packet size allowed) along the path,
 which can help in certain cases.
 When to use which?For most cases,
 tracepath is enough and safer great for workstations and normal users.If you need more control or are troubleshooting complex network issues,
 use traceroute,
 possibly with sudo.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Network Address Translation (NAT)
\series default
\color inherit
 was invented because there aren’t enough public IPv4 addresses for every device.
 Instead of giving each device a unique global IP,
 your provider gives your home one public IP.
 Your router assigns private addresses (like 192.168.x.x) to all your devices,
 and keeps a table matching each device’s private IP and port to a unique public port.
 When a device goes online,
 the router replaces its private IP with the public IP,
 saves the mapping,
 and sends replies to the right device based on this table.
 Besides saving IP addresses,
 NAT adds privacy and basic security:
 devices inside your network are not directly visible from the internet.
 If you want to make something accessible from outside,
 you set up port forwarding on the router.
 
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Tier 1 and Tier 2 networks
\series default
\color inherit
 The internet is made up of many networks,
 but not all are equal.
 Tier 1 networks are the top-level backbone providers huge companies (like AT&T,
 Tata,
 NTT,
 Level 3/CenturyLink) that can reach every other network on the internet without paying anyone else for transit.
 They do this by peering directly with all other Tier 1 networks and exchanging traffic for free (settlement-free peering).
 Tier 1s basically form the "core" of the global internet.
 Tier 2 networks are a level below.
 They usually have to pay Tier 1 networks for access to some parts of the internet (this is called IP transit),
 but they may also peer directly with other Tier 2s and smaller networks.
 ISPs (Internet Service Provider),
 regional carriers,
 and large hosting providers are often Tier 2.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Tier 3 ISPs
\series default
\color inherit
 are local or regional internet providers that connect homes and small businesses to the internet.
 They don’t have their own global backbone;
 instead,
 they buy all their internet access from bigger ISPs (Tier 2 or Tier 1 networks).
 Tier 3 providers focus on last-mile delivery and customer support,
 making sure users in their area get connected.
 Most people get their internet from a Tier 3 ISP,
 which acts as the final step between you and the wider internet.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Routing Autonomous System (AS or ASN for BGP)
\series default
\color inherit
.
 The global internet is made up of thousands of Autonomous Systems (AS).
 Each AS is a large group of IP addresses managed by one organization (like an ISP,
 big company,
 or university),
 and is identified by a unique ASN (Autonomous System Number).
 To create your own AS,
 you first need to officially receive a big block of public IP addresses (from a regional registrar like RIPE,
 ARIN,
 or APNIC) and then register an ASN.
 Only after that can you connect to other networks as a separate AS and use BGP to exchange routes.
 Once you have your own IP range and ASN,
 you can peer with other ASes,
 sell IP space to other providers,
 and even provide internet to others just like the big players.
 ASes use BGP (Border Gateway Protocol) to advertise which IP ranges they can route.
 This is how the global routing table is built,
 and why traffic knows which path to take across the world.
 Tier 1 AS:
 giant backbones,
 connect directly to all other Tier 1s,
 never pay for transit.
 Tier 2 AS:
 buy internet from Tier 1,
 may peer with others.
 Tier 3 AS:
 connect end-users,
 buy all connectivity from higher tiers.
 Every ISP,
 hosting company,
 or cloud provider is an AS.
 The AS system allows the internet to scale,
 set routing and security rules,
 and ensures redundancy (multiple paths).
 When you go online,
 your data travels from your home LAN (private IPs/NAT),
 through your Tier 3 ISP’s AS,
 up through bigger ASes,
 all connected and managed using BGP.
 So,
 if you own a large enough block of public IPs and get your own ASN,
 you can become an AS yourself connect to other networks,
 sell IP space,
 and become part of the global backbone.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
127.0.0.1
\series default
\color inherit
 is the “loopback” address,
 also known as localhost.
 When your computer sends data to 127.0.0.1,
 it never leaves the machine the data just loops back and stays inside.
 This address is used for testing,
 running local servers,
 and letting programs talk to each other on the same computer without any network hardware.
 Every device reserves 127.0.0.1 for itself;
 it’s never used to reach other devices.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
::1
\series default
\color inherit
 is the IPv6 loopback address,
 the same as 127.0.0.1 in IPv4.
 It lets your computer send data to itself without touching the network useful for local testing and running servers on your own machine.
 IPv6 is the new version of the internet protocol,
 made because IPv4 addresses ran out.
 IPv6 uses much longer addresses (like 2001:0db8:85a3::8a2e:0370:7334) and has enough space for every device in the world to get a unique IP.
 With IPv6,
 ::1 is always reserved as the loopback address for local use.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
0.0.0.0/0 and ::/0 networks in the routing table.

\series default
\color inherit
 Every router or device on the network keeps a routing table,
 which tells it where to send packets for different IP ranges.
 When a packet arrives,
 the router checks if it has a specific route for the destination IP.
 If yes,
 it forwards the packet along that path.
 If it doesn’t have a matching route,
 it uses the default route (0.0.0.0/0 for IPv4 or ::/0 for IPv6) to send the packet to its default gateway or the next higher-level router.
 Each router along the way repeats this process until the packet reaches a network that knows how to deliver it to the final destination.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Ranges of IPv4 multicast and experimental addresses.
 
\series default
\color inherit
Multicast is a way to send one packet to multiple receivers at the same time but not to everyone (like broadcast),
 just to devices that joined a specific group.
 It’s used for things like streaming video to a group,
 online games,
 or letting devices find each other on the local network.
 The multicast range is 224.0.0.0 to 239.255.255.255,
 but not all addresses are used the same way:
 
\end_layout

\begin_layout Itemize
224.0.0.0 to 224.0.0.255 For network control and discovery inside the local network only.
 These addresses are used by routers and protocols like OSPF,
 RIP,
 or mDNS,
 and never leave the local subnet.
 Example:
 224.0.0.1 means “all devices on this subnet”.
\end_layout

\begin_layout Itemize
224.0.1.0 to 238.255.255.255 For general multicast applications.
 These addresses can be routed across networks if allowed.
 Used for things like IPTV,
 large group calls,
 or multi-site streaming.
\end_layout

\begin_layout Itemize
239.0.0.0 to 239.255.255.255 For private multicast inside a company or organization.
 These addresses are not supposed to be routed on the public internet,
 only inside your organization’s network.
 Like “private IPs” but for multicast.
 Experimental addresses (240.0.0.0 to 255.255.255.254) are reserved and not used in the public internet.
\end_layout

\begin_layout Subsection

\color blue
Search some information about AS1741
\end_layout

\begin_layout Enumerate
Which organisation or company advertises AS1741 with BGP?
\end_layout

\begin_layout Enumerate
List some public peering exchange points the AS1741 connects to?
\end_layout

\begin_layout Enumerate
To which regional internet registry (RIR) the AS1741 belongs to?
\end_layout

\begin_layout Enumerate
What is the contact email address/phone/web form if you would need to inform some security or abuse issues to the owner of the AS1741?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
Which organisation or company advertises AS1741 with BGP?

\color inherit
 
\series default
I searched for AS1741 on bgp.he.net and found that it is advertised by CSC - Tieteen tietotekniikan keskus Oy,
 which is known as Funet.
 This is Finland’s national research and education network.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename tieteentech.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
List some public peering exchange points the AS1741 connects to.
\end_layout

\begin_deeper
\begin_layout Standard
I visited peeringdb.com and found a list of public peering exchange points for AS1741.
 According to the information on the site (see screenshot below),
 AS1741 is connected to several IXPs in Finland,
 including:
\end_layout

\begin_layout Itemize
FICIX 1 (Espoo) 100G
\end_layout

\begin_layout Itemize
FICIX 2 (Helsinki) 100G
\end_layout

\begin_layout Itemize
FICIX 3 (Oulu) 10G
\end_layout

\begin_layout Itemize
TREX Tampere 10G
\end_layout

\begin_layout Standard
For each IXP,
 both IPv4 and IPv6 connections are listed.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename peering.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
To which regional internet registry (RIR) the AS1741 belongs to?
\end_layout

\begin_deeper
\begin_layout Standard
I checked ipinfo.io where it says that the “Registry” for AS1741 is RIPE (Réseaux IP Européens) which is the Regional Internet Registry for Europe.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ripe.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
What is the contact email address/phone/web form if you would need to inform some security or abuse issues to the owner of the AS1741?
\end_layout

\begin_deeper
\begin_layout Standard
All related information about the security is on below screenshot.
 AS1741 is owned and operated by CSC - Tieteen tietotekniikan keskus Oy,
 the Finnish national research and education network provider (Funet).:
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename security.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection

\color blue
What it the difference between static and dynamic routing?
 Use example(s)
\end_layout

\begin_layout Standard
The difference between static and dynamic routing is that static routing relies on routes that are manually configured by a network administrator,
 while dynamic routing allows routers to automatically learn and update routes using special protocols.
 With static routing,
 the network administrator sets up specific paths for traffic,
 and these routes do not change unless someone manually edits them.
 This method is simple and works well for small or stable networks,
 but if something in the network changes,
 like a link fails,
 the route will not update on its own.
 For example,
 in a small office,
 an administrator might add a static route telling Router A to send all traffic for a certain network through Router B.
 If Router B goes offline,
 the connection breaks until someone changes the route manually.
 In contrast,
 dynamic routing uses protocols like OSPF,
 RIP,
 or BGP,
 which enable routers to share information about the network and automatically adjust routes if the network changes.
 This is useful in larger or more complex networks,
 because if a link fails or a new router is added,
 the system will quickly update itself and find the best available path without human intervention.
 In summary,
 static routing is manual and straightforward,
 but does not adapt to changes,
 while dynamic routing is automated and flexible,
 able to respond to changes in real time.
\end_layout

\begin_layout Subsection

\color blue
Describe briefly these dynamic routing protocols
\end_layout

\begin_layout Enumerate
RIP
\end_layout

\begin_layout Enumerate
OSPF and IS-IS
\end_layout

\begin_layout Enumerate
BGP
\end_layout

\begin_layout Enumerate
RPL (ripple)
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
RIP (Routing Information Protocol)
\series default
\color inherit
 is a classic distance-vector routing protocol that was one of the first dynamic protocols used in TCP/IP networks.
 RIP works by having routers periodically (every 30 seconds) exchange information with their neighbors about how many hops it takes to reach various networks.
 Each router keeps a simple routing table with the shortest hop count to each destination.
 The protocol is very easy to configure and understand,
 making it popular for small or simple networks.
 However,
 RIP has several limitations:
 it only allows up to 15 hops,
 which means it cannot be used in large networks,
 and it is slow to react to changes,
 so convergence (the process of all routers learning the best paths) can take a long time.
 Also,
 because it only cares about hop count and not bandwidth or delay,
 it may choose suboptimal paths.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
OSPF and IS-IS
\series default
\color inherit
 are both modern routing protocols used mostly inside large organizations and by internet providers.
 They don’t just look at the number of hops,
 like older protocols,
 but actually build a complete map of the network by exchanging information between all routers.
 Each router then figures out the best route to any destination using an algorithm called Dijkstra’s,
 which basically finds the shortest path.
 OSPF is made specifically for IP networks and divides them into smaller “areas” to keep things organized and efficient.
 IS-IS works in a very similar way,
 but it was first created for a different kind of network (the OSI model),
 and over time it turned out to be super flexible and reliable so now it’s also used by a lot of big ISPs.
 Both protocols can react quickly if something changes or breaks in the network,
 and they have features like security and load balancing that make them suitable for complex setups.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
BGP,
 or Border Gateway Protocol
\series default
\color inherit
,
 is basically the protocol that keeps the global Internet running.
 It decides how data gets from one big network (like an ISP or a company) to another,
 all around the world.
 Unlike older routing protocols that just look for the shortest or fastest path,
 BGP lets networks set their own rules for which routes to use for example,
 preferring cheaper or faster connections,
 or avoiding certain networks altogether.
 Routers using BGP talk to each other and exchange lists of which networks they can reach,
 plus extra info about how to get there,
 like the list of networks (AS numbers) the data would pass through.
 The cool thing about BGP is that it’s super flexible and powerful,
 so it can handle the massive scale of the whole Internet.
 But because it’s so important and complex,
 configuring BGP wrong can accidentally mess up the Internet for millions of people and that’s happened before.
 So BGP gives you a lot of control,
 but it also means you have to be careful.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
RPL (Routing Protocol for Low-power and Lossy Networks)
\series default
\color inherit
,
 sometimes called “ripple,” is a special routing protocol made for Internet of Things (IoT) setups think sensors,
 smart meters,
 or tiny devices running on batteries that connect over spotty wireless networks.
 The main idea behind RPL is to help these devices find reliable paths to send their data to a central hub or gateway,
 even if some connections are weak or keep changing.
 Instead of regular routing tables,
 RPL builds a sort of flexible tree (called a DODAG),
 which lets data flow around problems like dead links or devices that drop offline.
 It takes into account things like link quality or how much energy devices have left,
 so it can pick the most efficient routes.
 That’s why RPL works really well in places like smart homes,
 factories with lots of sensors,
 or city-wide smart infrastructure anywhere there are lots of simple,
 wireless devices that need to get their data back to a main server,
 even if the network is kind of unreliable.
\end_layout

\begin_layout Subsection

\color blue
Create a DNS request (any tool such as ping,
 nslookup,
 whatever) to resolve the IP address of www.oamk.fi
\end_layout

\begin_layout Enumerate
Use some IP whois lookup web service to resolve which company is hosting and has that IP address and server?
 (www.oamk.fi)
\end_layout

\begin_layout Enumerate
What is the inetnum or route/network (IP address range) the www.oamk.fi's IP address belongs to?
\end_layout

\begin_layout Enumerate
What is abuse contact email address of that network range?
\end_layout

\begin_layout Standard
I used the ping command to find out the IP address of www.oamk.fi.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted8.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I ran the whois command on this IP to see who owns it and which network it belongs to.
 The output said that the IP address is part of the range 95.216.0.0 - 95.217.255.255,
 and that this whole network is managed by Hetzner Online GmbH,
 which is a German hosting company.
 In the same whois result,
 I also found the abuse contact email for this network,
 which is abuse@hetzner.com
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted9.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Use traceroute (tracert in MS Windows command shell) to www.whitehouse.gov
\end_layout

\begin_layout Standard
What is the internet service provider's first router IP address near you?
 (it's most likely the 2nd router/hop,
 immediately after your home network)
\end_layout

\begin_layout Enumerate
How many hops (routers) are there to the www.whitehouse.gov from your device?
\end_layout

\begin_layout Enumerate
Use traceroute again,
 but this time to Google's public DNS server in 8.8.8.8,
 and Quad9 DNS in 9.9.9.9.
 How far are those?
\end_layout

\begin_layout Enumerate
Why traceroute does not always work,
 and does not show the route up to the final destination IP,
 or there are timeouts for some routers (* is timeout)?
 For example,
 IP address of education.gov.au
\end_layout

\begin_layout Enumerate
Use traceroute and DNS to estimate/guess from response DNS names,
 round trip times,
 and with IP whois lookups,
 where the web server reliefweb.int is located (continent,
 country or so)?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate
The first hop is my home router (192.168.1.1),
 and the second hop (91.159.136.2) is most likely the first router of my Internet service provider.
 The traceroute shows a total of 7 hops before timeouts start appearing.
 The route does not reach all the way to the destination,
 which is common due to network security settings and firewalls that block traceroute probes.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted10.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
After that,
 I ran traceroute to Google’s public DNS server (8.8.8.8) and to Quad9 DNS (9.9.9.9).
 For 8.8.8.8,
 the traceroute reached the destination in 7 hops (the 7th hop was 108.170.238.171,
 which is part of Google’s network).
 For 9.9.9.9,
 the traceroute only showed 4 hops before getting only timeouts (stars) for the rest,
 which means the packets reached the Quad9 DNS network (the last visible hop was 195.140.192.28,
 which is in Tampere,
 Finland),
 but further hops were not shown,
 possibly due to firewalls or network restrictions.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted11.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Traceroute does not always show the route all the way to the final destination because some routers or firewalls on the path are configured to ignore or block the traceroute packets (ICMP or UDP).
 This is often done for security reasons,
 to prevent outside users from mapping internal network structure or to reduce unnecessary network load.
 When a router does not respond,
 traceroute will show a star (*) and a timeout for that hop.
 For some websites,
 like education.gov.au,
 the final server or several routers near the end may not respond at all,
 so the route appears incomplete,
 even if the website itself is working.
 This is normal and expected on many networks.
\end_layout

\begin_layout Enumerate
To estimate where the web server for reliefweb.int is located,
 I used traceroute and saw that the last responding hop was nyk-b17-link.ip.twelve99.net (62.115.137.15).
 I am not sure about the exact location of this router,
 but then I checked the IP address of reliefweb.int (52.87.133.138) using whois.
 The whois result showed that this address belongs to Amazon Technologies Inc.
 (AWS) in Seattle,
 United States.
 So,
 even though the traceroute did not reach the actual server,
 based on the whois lookup I can say that reliefweb.int is hosted on AWS in the US.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename traceroute-nyk.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Use Ficix statistics web page and answer:
\end_layout

\begin_layout Enumerate
What is the most quiet IP traffic hour in the Ficix 1 exchange point?
\end_layout

\begin_layout Enumerate
Which organisations or companies are connected to Ficix 3?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
According to the Ficix 1 statistics page,
 the most quiet IP traffic hour was approximately between 03:00–06:00 (EEST),
 when the traffic dropped to its lowest value.
 This is clearly visible on the traffic graph,
 where both inbound and outbound traffic reached their minimum during this time.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted12.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
According to the Ficix statistics page,
 the following organisations and companies are connected to Ficix 3:
 CSC,
 Cinia,
 DNA,
 Elisa AS719,
 FNE,
 GleSYS,
 Kaisanet,
 Lounea,
 Telia,
 and Valoo:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted13.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
List all private IPv4 networks (RFC1918)
\end_layout

\begin_layout Standard
The private IPv4 networks defined by RFC1918 are:
\end_layout

\begin_layout Itemize
10.0.0.0 – 10.255.255.255 (10/8 prefix)
\end_layout

\begin_layout Itemize
172.16.0.0 – 172.31.255.255 (172.16/12 prefix)
\end_layout

\begin_layout Itemize
192.168.0.0 – 192.168.255.255 (192.168/16 prefix)
\end_layout

\begin_layout Standard
These address ranges are reserved for use in private networks and are not routed on the public internet.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted14.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
What is the purpose of IPv4 private networks?
\end_layout

\begin_layout Standard
The main purpose of IPv4 private networks is to help deal with the shortage of public IPv4 addresses,
 by letting different networks use the same private address ranges internally.
 This way,
 organizations and home users can connect as many devices as they want without taking up public address space.
 Besides saving addresses,
 private networks also make it easier to organize and manage local networks,
 because internal traffic can stay within the local network and does not have to travel over the public internet.
 Private addresses also improve security,
 since devices with private IPs are not reachable directly from outside you need special rules or port forwarding to allow access from the internet.
 In summary,
 private networks help save public IP addresses,
 make local networking simpler,
 and add a basic layer of security.
\end_layout

\begin_layout Subsection

\color blue
List and explain three or more purposes and features of the ICMP and or ICMPv6 protocol
\end_layout

\begin_layout Standard
ICMP (Internet Control Message Protocol) and its IPv6 version,
 ICMPv6,
 are protocols that work together with IP at the network layer (layer 3) of the OSI model.
 Their main purpose is not to transfer user data,
 but to send control and error messages that help manage and troubleshoot networks.
 One important feature of ICMP is error reporting.
 If a router cannot deliver a packet for example,
 because the destination is unreachable,
 the network is down,
 or a port is blocked it sends back an ICMP “Destination Unreachable” message to the sender.
 Another key feature is handling situations where packets loop around the network:
 if the “time to live” (TTL) of a packet reaches zero,
 the router sends an ICMP “Time Exceeded” message,
 which helps prevent endless loops.
 ICMP is also the foundation for network diagnostic tools.
 The most common example is the ping command,
 which uses ICMP Echo Request and Echo Reply messages to test if another device is reachable and to measure round-trip time.
 The traceroute tool uses ICMP messages to discover the path packets take through the network,
 by intentionally causing TTL to expire at each hop and recording the routers that respond.
 In IPv6,
 ICMPv6 has even more responsibilities.
 It not only does error reporting and diagnostics,
 but also supports Neighbor Discovery,
 which lets devices on the same local network automatically find each other,
 learn each other's addresses,
 and even configure their own IPv6 addresses without manual setup.
\end_layout

\begin_layout Subsection

\color blue
Try to solve these basic IP subnet calculations without checking the solutions:
\end_layout

\begin_layout Enumerate
If network address is 192.168.100.0,
 and subnet mask is 255.255.255.224,
 what is the broadcast address of the network?
\end_layout

\begin_layout Enumerate
If network address is 1.2.3.4,
 and broadcast address is 1.2.3.7,
 what is the subnet mask of the network?
\end_layout

\begin_layout Enumerate
If broadcast address is 192.168.129.255 and network mask is 255.255.254.0,
 what is the network address of the network?
\end_layout

\begin_layout Standard
A subnet mask is a number used in IP networking to separate the network part of an IP address from the host part.
 Technically,
 a subnet mask is just a sequence of 32 bits,
 written as four numbers separated by dots (for example,
 255.255.255.0).
 Each of these numbers is actually a group of eight bits.
 The reason we usually see subnet masks written in decimal (like 255.255.255.224) is simply because it’s easier for humans to read,
 but computers always work with them in binary (ones and zeros).
 For example,
 the mask 255.255.255.224 looks like this in binary:
 11111111.11111111.11111111.11100000.
 The “1” bits mean “network part,” and the “0” bits mean “host part.” So here,
 the first 27 bits are for the network,
 and the last 5 bits are for devices in that network.
 Some common subnet masks and what they look like in both decimal and binary:
\end_layout

\begin_layout Itemize
255.255.255.0 (/24):
 11111111.11111111.11111111.00000000 —
 256 addresses per network
\end_layout

\begin_layout Itemize
255.255.255.128 (/25):
 11111111.11111111.11111111.10000000 —
 128 addresses per network
\end_layout

\begin_layout Itemize
255.255.255.224 (/27):
 11111111.11111111.11111111.11100000 —
 32 addresses per network
\end_layout

\begin_layout Standard
Subnet masks are important because they help devices figure out which other devices are “local” and which ones are on another network,
 and they make it possible to split large networks into smaller,
 easier-to-manage parts.
\end_layout

\begin_layout Enumerate
If the network address is 192.168.100.0 and the subnet mask is 255.255.255.224:
 
\end_layout

\begin_deeper
\begin_layout Enumerate
The mask 255.255.255.224 is 27 ones and 5 zeros in binary,
 so the block size is 32 addresses (2⁵ = 32).
\end_layout

\begin_layout Enumerate
The network address is 192.168.100.0.
 
\end_layout

\begin_layout Enumerate
The broadcast address is the last address in the block:
 192.168.100.31.
 So the broadcast address for this network is 192.168.100.31.
\end_layout

\end_deeper
\begin_layout Enumerate
The answer is pretty easy to make we calculate 7-[4](4 included) = 4 addresses,
 4 = 2^2 so only 2 bits are free and the adjusting mask from the table for 30 ones is 255.255.255.252
\end_layout

\begin_layout Enumerate
254 in binary form is 11111110.
 The fourth number has 8 zeros.
 Altogether,
 there are 9 zeros in the mask,
 which means 2^9 = 512 addresses in the subnet.
 Since the broadcast address is 192.168.129.255,
 we need to count 512 addresses backwards to find the network address.
 The last bit in the 129 part represents only one address,
 so when we subtract this range,
 we go back to 128.
 With all the last 8 bits as zeros,
 the final result is 192.168.128.0.
\end_layout

\begin_layout Subsection

\color blue
Try to solve these IP subnetting assignments without checking the solutions and document at least some examples/answers to the learning diary.
 Answers should contain (for each subnet):
 Network address,
 broadcast address and subnet mask:
\end_layout

\begin_layout Itemize
Subnetting task 1:
 The address space available is 172.16.64.0/23.
 Subnet it and create 5 (A,
 B,
 C,
 D and E) IPv4 subnets with following amount of hosts in each network:
 A = 85,
 B = 45,
 C = 95,
 D = 57,
 E = 34.
 Leave some small amount of free addresses to each subnet.
 Avoid unnecessary waste of IPs.
\end_layout

\begin_layout Itemize
Subnetting task 2:
 Same as task 1,
 but available address space is now 192.168.0.0/25 and networks/hosts are:
 A = 28,
 B = 10,
 C = 60,
 D = 4.
 Leave some small amount of free addresses to each subnet.
 Avoid unnecessary waste of IPs.
\end_layout

\begin_layout Itemize
Subnetting task 3:
 IPv6 address space available:
 2001:708:510::/48.
 Create four /64 IPv6 networks.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Subnetting task 1
\series default
\color inherit
 .
 So 172.16.64.0/23.
 This means we have the same situation as in the previous task:
 the subnet mask has 9 zeros,
 which gives us 512 available addresses.
 When creating subnets,
 the number of hosts probably does not include the broadcast address,
 but each subnet must have the last address reserved for broadcast.
 As we already know,
 there are 512 addresses in total.
 We could just divide the 512 addresses evenly into 5,
 but we want to avoid wasting extra IPs.
 So,
 for each subnet,
 I add 2 to the required number of hosts (to account for the network and broadcast addresses),
 then choose the next power of two as the subnet size.
\end_layout

\begin_deeper
\begin_layout Enumerate
85 + 2 = 87 capacity 128
\end_layout

\begin_layout Enumerate
45 + 2 = 47 capacity 64
\end_layout

\begin_layout Enumerate
95 + 2 = 97 capacity 128
\end_layout

\begin_layout Enumerate
57 + 2 = 59 capacity 64
\end_layout

\begin_layout Enumerate
34 + 2 = 36 capacity 64
\end_layout

\begin_layout Standard
So the total is 128 + 64 + 128 + 64 + 64 = 448bits for all subnets together.
\end_layout

\begin_layout Standard
It is important to mention that we use powers of two not by chance,
 but because subnetting is based on bits,
 and we need to keep all subnet blocks aligned,
 with no gaps or overlaps.
 In the next step,
 I will arrange (“stretch out”) these blocks in a line,
 starting from 172.16.64.0,
 so that each subnet directly follows the previous one.
 Also the subnet is not that difficult to count we just see the amount of addresses and 255 - this amount + 1.
 and that would be the subnet mask /25 and /26 in the answer means exacley about that bit which we subtracted in a previous task.
\end_layout

\begin_layout Enumerate
for A :
 172.16.64.0 - 172.16.64.127 (capacity 128);
 Broadcast is the last in this range (172.16.64.127) ;
 Subnet mask:
 255.255.255.128/25.
\end_layout

\begin_layout Enumerate
C I will use straight after A because it is easier to count :
 C :
 172.16.64.128 - 172.16.64.255 (capacity 128);
 Broadcast is the last in this range (172.16.64.255);
 Subnet mask:
 255.255.255.128/25.
\end_layout

\begin_layout Enumerate
for B :
 172.16.65.0 - 172.16.65.63 (capacity 64) ;
 Broadcast is the last in this range 172.16.65.63;
 Subnet mask:
 255.255.255.192/26.
\end_layout

\begin_layout Enumerate
for D :
 172.16.65.64 - 172.16.65.127 (capacity 64) ;
 Broadcast is the last in this range 172.16.65.127;
 Subnet mask:
 255.255.255.192/26.
\end_layout

\begin_layout Enumerate
for E :
 172.16.65.128 - 172.16.65.191 (capacity 64);
 Broadcast is the last in this range 172.16.65.191;
 Subnet mask:
 255.255.255.192/26.
\end_layout

\begin_layout Enumerate
The remaining addresses (172.16.65.192 —
 172.16.65.255) are left free and can be used for future networks.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
Subnetting task 2
\series default
\color inherit
 :
 192.168.0.0/25 Is a total space of IPs means we have 7 zeros.
 So the mask would be 255.255.255.128/25.
 Then we use absolutely the same algorythm as in the previous task.
 I will skip some steps since I showed them in the task 1 and I will list pnly the answers in decreasing mode:
\end_layout

\begin_deeper
\begin_layout Enumerate
capacity = 64
\end_layout

\begin_layout Enumerate
capacity = 32
\end_layout

\begin_layout Enumerate
capacity = 16
\end_layout

\begin_layout Enumerate
capacity = 8
\end_layout

\begin_layout Standard
sum = 120
\end_layout

\begin_layout Standard
free IPs left = 128 - 120 = 8.
\end_layout

\begin_layout Enumerate
(c) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.0 – 192.168.0.63;
 192.168.0.63;
 255.255.255.192 (/26)
\end_layout

\begin_layout Enumerate
(a) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.64 – 192.168.0.95;
 192.168.0.95;
 255.255.255.224 (/27)
\end_layout

\begin_layout Enumerate
(b) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.96 – 192.168.0.111;
 192.168.0.111;
 255.255.255.240 (/28)
\end_layout

\begin_layout Enumerate
(d) (Subnet range,
 Broadcast,
 Mask) = 192.168.0.112 – 192.168.0.119;
 192.168.0.119;
 255.255.255.248 (/29)
\end_layout

\end_deeper
\begin_layout Standard

\series bold
\color brown
Subnetting task 3
\series default
\color inherit
:
 The /48 prefix means that the first three blocks (2001:708:510) are fixed for all addresses in this range.
 To create four /64 subnets,
 we use the next (fourth) block as the subnet number and set it to 0,
 1,
 2,
 and 3.
 Each subnet will look like this:
\end_layout

\begin_layout Itemize
2001:708:510:0::/64
\end_layout

\begin_layout Itemize
2001:708:510:1::/64
\end_layout

\begin_layout Itemize
2001:708:510:2::/64
\end_layout

\begin_layout Itemize
2001:708:510:3::/64
\end_layout

\begin_layout Standard
In IPv6,
 there are no broadcast addresses,
 so you don’t need to reserve anything for broadcast.
 Each /64 subnet has a huge number of available addresses,
 and this method of subnetting is standard in IPv6.
\end_layout

\begin_layout Part*
Week #3
\end_layout

\begin_layout Subsection

\color blue
Answer these questions:
 
\end_layout

\begin_layout Enumerate
Explain shortly the purpose of TCP acknowledgment and sequence numbers
\end_layout

\begin_layout Enumerate
What is the purpose of TCP SYN bit?
\end_layout

\begin_layout Enumerate
What is the purpose of TCP reset bit?
\end_layout

\begin_layout Enumerate
When TCP retransmissions occur?
\end_layout

\begin_layout Enumerate
What is flow-control?
 (for IP family protocols such as TCP)
\end_layout

\begin_layout Enumerate
Explain TCP connection state LISTENING
\end_layout

\begin_layout Enumerate
Explain TCP connection state ESTABLISHED
\end_layout

\begin_layout Enumerate
What is the purpose of TCP or UDP source port?
\end_layout

\begin_layout Enumerate
What is the purpose of TCP or UDP destination port?
\end_layout

\begin_layout Enumerate
What are the common well-known network service names for these TCP ports:
 22,
 23,
 25,
 80,
 443,
 3306?
\end_layout

\begin_layout Enumerate
What are common connection-oriented protocol features/advantages,
 and why TCP is such protocol?
\end_layout

\begin_layout Enumerate
What are connectionless protocols features (or lack of),
 and why UDP is connectionless protocol?
\end_layout

\begin_layout Enumerate
Why most services using UDP prefer max 512 byte UDP datagrams?
\end_layout

\begin_layout Enumerate
When it is more reasonable to use UDP instead of TCP?
\end_layout

\begin_layout Enumerate
What is the length of TCP header without extra options?
 What about UDP header?
\end_layout

\begin_layout Enumerate
What is TCP Nagle’s algorithm?
 When it should be disabled for networking applications?
\end_layout

\begin_layout Enumerate
What is Maximum Transmission Unit (MTU) and IPv4 fragmentation?
\end_layout

\begin_layout Enumerate
What is a raw socket?
\end_layout

\begin_layout Enumerate
What is port forwading?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate
When you send data over TCP,
 it gets split into small pieces called packets.
 In real networks,
 these packets can arrive out of order,
 get lost along the way,
 or even show up more than once.
 To guarantee that everything is delivered correctly and nothing is missing,
 TCP uses two special kinds of numbers:
 sequence numbers and acknowledgment numbers.
 Sequence numbers work like this:
 every byte of data that gets sent is assigned its own unique number.
 When a packet is transmitted,
 its header contains the sequence number of the first byte of data inside that packet.
 Thanks to these numbers,
 the receiving side can put all the pieces of data back together in the right order,
 even if they arrive all jumbled up.
 If some piece is missing,
 the gap in the sequence numbers immediately reveals which part got lost,
 and the receiver can ask for it to be resent.
 Acknowledgment numbers serve another purpose:
 whenever the receiver gets new data,
 it sends back a message saying which byte it expects to receive next.
 This tells the sender that all bytes up to that number have already arrived safely,
 and that it’s time to send the next piece.
 If an acknowledgment isn’t received for a while,
 the sender knows that something went wrong and can retransmit the missing data.
 Here’s how it works in practice.
 When a connection is first established,
 both sides agree on which sequence numbers to start from.
 This happens using special flags in the TCP protocol called SYN and ACK (these are just flags to indicate the type of message,
 not actual sequence numbers themselves).
 After that,
 as data is transmitted,
 suppose the sender sends a packet with a sequence number of 1000 and includes 500 bytes of data.
 The receiver,
 upon getting these bytes,
 sends back an acknowledgment number of 1500.
 This means everything up to byte 1499 has been successfully received and the next byte expected should have the number 1500.
 If any of the data gets lost in transit and isn’t acknowledged,
 the sender will notice the missing acknowledgment and resend the necessary data.
 
\color magenta
[https://ru.stackoverflow.com/questions/566637/]
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP SYN 
\series default
\color inherit
bit is used during the very beginning of a TCP connection,
 in what’s called the “three-way handshake.” Its main purpose is to synchronize the sequence numbers between the two computers that want to communicate.
 Here’s how it works in practice:
 When one computer wants to establish a TCP connection with another,
 it sends a packet with the SYN flag set.
 This first SYN packet tells the receiver,
 “I want to start a conversation,
 and here is the initial sequence number I’d like to use.” This initial sequence number is important because it marks where the counting of bytes will begin for the data being sent.
 When the receiving computer gets this SYN packet,
 it replies with its own packet that has both the SYN and ACK flags set.
 This reply serves two purposes at once:
 First,
 it acknowledges that it received the first SYN by setting the ACK flag and including the expected next sequence number.
 Second,
 by also setting the SYN flag,
 it tells the initiator,
 “Okay,
 I’m ready too,
 and here’s the starting sequence number I want to use for my side of the communication.” Finally,
 the initiating computer sends one more ACK packet to confirm that it received the server’s response,
 and now both sides know which sequence numbers they’ll be using to track the conversation.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP reset bit,
 called the RST flag
\series default
\color inherit
,
 is used to immediately end a TCP connection or to reject an attempt to start one.
 When a packet arrives with the reset bit set,
 it tells the other side to instantly stop using that connection.
 This usually happens if one side receives unexpected data for a connection that doesn’t exist,
 or if a server receives a request on a closed port.
 For example,
 in security situations,
 if an attacker tries to connect to a protected or closed port,
 the server can respond with a TCP packet that has the RST flag set.
 This instantly tells the attacker that the connection is not allowed and to stop trying.
 Firewalls can also use the reset bit to automatically cut off suspicious or unauthorized connection attempts,
 making sure that attackers cannot find out which services are running.
 In this way,
 the reset bit helps quickly reject unwanted or suspicious connections and protects the server’s resources.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
TCP retransmissions
\series default
\color inherit
 happen when the data sent from one computer does not reach the other computer or is not confirmed as received.
 If the sender does not get a confirmation (an acknowledgment) after some time,
 it will send the same data again.
 This can happen if a packet is lost somewhere on the way or damaged.
 By resending the data,
 TCP makes sure that everything eventually arrives safely and in the right order,
 even if something goes wrong during transmission.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Flow control in TCP
\series default
\color inherit
 is a mechanism that prevents the sender from overwhelming the receiver with too much data at once.
 The main idea is that the sender might be able to send data much faster than the receiver can process or store it in its buffer.
 If this isn’t controlled,
 the receiver’s buffer could fill up,
 and some data might be lost.
 To avoid this problem,
 TCP uses a special field called the window size.
 This is a number that the receiver sends to the sender,
 telling it how many more bytes of data it is ready to accept at the moment.
 The sender is not allowed to send more data than what the current window size allows.
 Once the receiver has processed some of the data and has free space again,
 it sends an updated window size,
 and the sender can continue sending more data.
 For example,
 if the receiver is busy and its buffer is almost full,
 it can set the window size to zero.
 This tells the sender to stop sending new data until there is space again.
 When the receiver is ready,
 it increases the window size and informs the sender,
 which can then resume sending.
 In this way,
 flow control helps balance the speed between the sender and the receiver,
 prevents buffer overflow,
 and ensures that no data is lost just because one side is slower at handling the data.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP connection state LISTENING
\series default
\color inherit
 means that a server is waiting and ready to accept new incoming connections on a specific port.
 When a program (like a web server) wants to accept connections from clients,
 it creates a socket and puts it into the LISTENING state.
 In this state,
 the server is not yet connected to any client,
 but it is actively waiting for connection requests.
 As soon as a client tries to connect (by sending a SYN packet),
 the server can respond and begin establishing a new TCP connection.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The TCP connection state ESTABLISHED
\series default
\color inherit
 means that a full two-way connection has been successfully set up between the client and the server,
 and both sides can now send and receive data.
 In this state,
 the three-way handshake is complete,
 and the connection is ready for actual data transfer.
 Any information sent by either side will be reliably delivered to the other side.
 Most of the time when two computers are actively communicating over TCP,
 their connection is in the ESTABLISHED state.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The source port
\series default
\color inherit
 is a number included in every TCP or UDP packet that identifies which application or process on the sender’s device sent the data.
 This allows the receiving device to know where replies should be sent,
 and it lets the sender’s own operating system deliver any response to the correct program when it comes back.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
The destination port
\series default
\color inherit
 is a number in each TCP or UDP packet that specifies which application or service on the receiving device should get the incoming data.
 When a device receives a packet,
 it looks at the destination port to decide which program or service should handle that data.Source and destination ports together make sure that data flows between the correct applications on both sides,
 so replies return to the right sender,
 and new incoming data gets delivered to the right receiver.
\end_layout

\begin_layout Enumerate
Here are the common,
 well-known network services for those TCP ports:
\end_layout

\begin_deeper
\begin_layout Itemize
22:
 SSH (Secure Shell)
\end_layout

\begin_layout Itemize
23:
 Telnet
\end_layout

\begin_layout Itemize
25:
 SMTP (Simple Mail Transfer Protocol)
\end_layout

\begin_layout Itemize
80:
 HTTP (HyperText Transfer Protocol)
\end_layout

\begin_layout Itemize
443:
 HTTPS (HyperText Transfer Protocol Secure)
\end_layout

\begin_layout Itemize
3306:
 MySQL Database Service
\end_layout

\begin_layout Standard
These are standard assignments used across the internet,
 so when you see these port numbers,
 they usually mean the listed service is running on that port.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\color brown
A connection-oriented protocol 
\series default
\color inherit
like TCP is designed to make sure data gets from one computer to another safely and in the right order.
 With TCP,
 before sending any actual information,
 both sides set up a connection and agree on how communication will happen.
 This setup allows TCP to guarantee that all data will arrive,
 that the order of the data will be preserved,
 and that any missing or damaged information will be detected and resent automatically.
 TCP can also slow down or speed up data transfer depending on the state of the receiver and the network.
 That’s why TCP is used for things like web browsing and file transfers,
 where reliability is more important than speed.
 The combination of these features is what makes TCP a connection-oriented protocol:
 it’s all about managing and controlling the connection from start to finish to make sure nothing is lost or mixed up.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
A connectionless protocol
\series default
\color inherit
,
 like UDP,
 sends data without setting up any formal connection between the sender and receiver.
 With UDP,
 each packet is sent independently and there’s no guarantee that packets will arrive,
 arrive in order,
 or even arrive at all.
 There is no mechanism for checking errors,
 confirming delivery,
 or resending lost data.
 This lack of extra steps makes UDP fast and efficient,
 but also less reliable than TCP.
 UDP is called connectionless because it simply sends packets out,
 without any handshake or ongoing management of the connection,
 making it a good fit for applications where speed matters more than reliability like online games,
 voice calls,
 or live streaming.
\end_layout

\begin_layout Enumerate
Most services using UDP prefer to keep their datagrams at 512 bytes or less because this size can usually be sent across different networks without getting split into smaller fragments.
 If a UDP datagram is larger than 512 bytes,
 it might have to be fragmented into multiple pieces as it travels over the Internet.
 Fragmentation increases the chance that some pieces will get lost,
 and if even one fragment is missing,
 the entire datagram is lost.
 Keeping datagrams at 512 bytes or less makes transmission more reliable and avoids problems with fragmentation and loss,
 which is especially important since UDP itself doesn’t guarantee delivery or provide automatic retransmission.
 This size also matches traditional limits in protocols like DNS,
 which was originally designed to fit entirely within a single 512-byte UDP packet.
\end_layout

\begin_layout Enumerate
It is more reasonable to use UDP instead of TCP when speed is more important than reliability,
 or when your application can tolerate some data loss,
 out-of-order packets,
 or duplication.
 UDP is the better choice for real-time applications like online gaming,
 voice or video calls,
 and live streaming,
 where it’s more important to get data quickly than to guarantee every single packet arrives perfectly.
 UDP is also useful when sending small,
 simple queries like DNS requests,
 where adding the overhead of connection setup and error-checking would only slow things down.
\end_layout

\begin_layout Enumerate
What is the length of TCP header without extra options?
 What about UDP header?
\end_layout

\begin_deeper
\begin_layout Itemize
TCP Header (20 bytes,
 default fields,
 no options):
\end_layout

\begin_deeper
\begin_layout Itemize
Source Port (2 bytes)
\end_layout

\begin_layout Itemize
Destination Port (2 bytes)
\end_layout

\begin_layout Itemize
Sequence Number (4 bytes)
\end_layout

\begin_layout Itemize
Acknowledgment Number (4 bytes)
\end_layout

\begin_layout Itemize
Data Offset + Reserved + Flags (2 bytes)
\end_layout

\begin_layout Itemize
Window Size (2 bytes)
\end_layout

\begin_layout Itemize
Checksum (2 bytes)
\end_layout

\begin_layout Itemize
Urgent Pointer (2 bytes)
\end_layout

\end_deeper
\begin_layout Itemize
UDP Header (8 bytes):
\end_layout

\begin_deeper
\begin_layout Itemize
Source Port (2 bytes):
 The sender’s port number
\end_layout

\begin_layout Itemize
Destination Port (2 bytes):
 The receiver’s port number
\end_layout

\begin_layout Itemize
Length (2 bytes):
 The total length of the UDP packet (header + data)
\end_layout

\begin_layout Itemize
Checksum (2 bytes):
 Error-checking for header and data
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted15.png
	scale 30

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
\color brown
TCP Nagle’s algorithm 
\series default
\color inherit
is a feature designed to reduce the number of small packets sent over the network.
 When enabled,
 it collects small outgoing messages and sends them all together as one larger packet,
 instead of sending each tiny message separately.
 This helps reduce network congestion and overhead.
 However,
 Nagle’s algorithm can introduce delays in applications that need to send many small messages quickly,
 especially those that rely on real-time or interactive communication,
 like online games,
 VoIP,
 instant messaging,
 or trading platforms.
 In these cases,
 the small delays caused by waiting for more data to “bundle” can negatively impact responsiveness.
 Nagle’s algorithm should be disabled (using the TCP_NODELAY option) for networking applications that require minimal latency and instant delivery of small messages,
 such as real-time games,
 chat apps,
 or low-latency financial trading systems.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Maximum Transmission Unit (MTU)
\series default
\color inherit
 is the largest size,
 in bytes,
 of a single packet that can be sent over a particular network link without needing to be broken up.
 Every network interface (like Ethernet,
 WiFi,
 etc.) has its own MTU value,
 for example,
 standard Ethernet is usually 1500 bytes.
 If an IPv4 packet is larger than the MTU of the network,
 it must be split into smaller pieces—
this process is called fragmentation.
 Each fragment is sent as a separate packet,
 and at the destination,
 all fragments are reassembled into the original,
 full packet.
 Fragmentation is handled at the IP layer,
 not by TCP or UDP.
 Fragmentation is generally avoided if possible,
 because it increases the chance of packet loss (if one fragment is lost,
 the whole original packet is lost),
 and reassembly takes extra processing time.
 That’s why most applications try to keep packets within the MTU size of the network path.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
A raw socket 
\series default
\color inherit
is a special type of network socket that gives a program direct access to lower-level network protocols.
 Unlike regular sockets (like TCP or UDP),
 raw sockets allow the application to send and receive packets with custom headers,
 and even craft entire packets from scratch.
 Raw sockets are often used for network diagnostics,
 custom protocol implementation,
 packet sniffing,
 or security tools—
anything where you need full control over the packet structure (for example,
 writing your own ping,
 traceroute,
 or firewall).
 Because they bypass normal protocol handling,
 raw sockets usually require special privileges (like root/admin access) for security reasons,
 since they can be used for things like packet spoofing or attacks.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Port forwarding
\series default
\color inherit
 is a technique used in networking where incoming connections to a specific port on one device (usually a router or firewall) are automatically redirected to another port and/or another device inside the local network.
 This allows external users or services on the internet to access a computer or service (like a web server,
 game server,
 or CCTV camera) inside a private network,
 even though that device doesn’t have a direct public IP address.
 For example,
 if you set up port forwarding on your router for port 80,
 any connection coming to your home’s public IP address on port 80 will be sent directly to a specified computer inside your local network,
 also on port 80 (or any other port you choose).
 Port forwarding is commonly used for hosting servers at home,
 remote desktop access,
 gaming,
 and other scenarios where devices on a private network need to be reachable from the outside world.
\end_layout

\begin_layout Subsection

\color blue
Describe these protocols or services shortly:
 
\end_layout

\begin_layout Enumerate
IPSec
\end_layout

\begin_layout Enumerate
RTP and RTCP
\end_layout

\begin_layout Enumerate
QUIC (IETF)
\end_layout

\begin_layout Enumerate
Wireguard
\end_layout

\begin_layout Enumerate
DoH
\end_layout

\begin_layout Enumerate
Round-robin DNS
\end_layout

\begin_layout Enumerate
LDAP
\end_layout

\begin_layout Enumerate
Radius
\end_layout

\begin_layout Enumerate
Syslog
\end_layout

\begin_layout Enumerate
NTP
\end_layout

\begin_layout Enumerate
SNMP
\end_layout

\begin_layout Enumerate
SMTP
\end_layout

\begin_layout Enumerate
SMB/CIFS
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
\color brown
IPSec
\series default
\color inherit
 is a set of protocols that keeps data safe when sending it over the internet between two devices or networks.
 The process starts with both sides deciding they want a secure connection,
 because regular IP packets can easily be intercepted or changed along the way.
 To set up this protection,
 both devices first need to agree on which encryption methods and keys they’ll use.
 They do this using the Internet Key Exchange (IKE) protocol,
 which lets them securely create a shared secret key,
 even though they’re talking over the open internet.
 Each side makes a public and a private value,
 exchanges the public part,
 and thanks to the math behind it (Diffie-Hellman),
 both can come up with the same secret key without anyone else figuring it out,
 even if someone is listening in.
 Now they both have matching keys and rules for how to protect the data,
 known as a security association.
 Once this is set up,
 IPSec steps in to protect the chosen traffic.
 Every time one side needs to send a packet,
 IPSec either encrypts it,
 signs it,
 or both depending on the agreed settings.
 It adds a special header for authentication (AH) or for encryption and authentication (ESP).
 In transport mode,
 only the data part of the packet is protected.
 In tunnel mode,
 the whole original packet gets wrapped up and hidden inside a new one,
 which is how VPNs usually work.
 The protected packet is then sent across the internet.
 When the other side receives it,
 it checks the signature,
 decrypts it if needed,
 and pulls out the original data before passing it along to the right app or network.
 This way,
 IPSec makes sure your data stays private and unchanged,
 even over public networks.
 That’s why it’s so widely used for VPNs and for safely connecting distant offices.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
RTP (Real-time Transport Protocol)
\series default
\color inherit
 is a protocol used to deliver audio and video over networks,
 like in video calls,
 online meetings,
 or IP telephony.
 When you’re in a voice or video chat,
 RTP is what actually moves the sound and video data between participants,
 making sure everything arrives quickly and in the right order for smooth playback.
 RTP doesn’t try to guarantee perfect delivery it’s designed for real-time use,
 so if a packet is late or missing,
 it just gets skipped (which is usually better than waiting and causing a lag).
 Each RTP packet has a sequence number and timestamp,
 so the receiver knows how to put everything back in order and sync up sound and video.
 Alongside RTP,
 there’s RTCP (RTP Control Protocol),
 which is like a helper protocol that travels alongside the main media stream.
 RTCP doesn’t carry actual media,
 but instead sends small control messages between the participants.
 These messages report things like packet loss,
 delay,
 or how well the connection is working.
 That way,
 applications (like Zoom,
 Skype,
 or any VoIP system) can monitor call quality in real time,
 adjust the stream if needed,
 and even show users stats like “poor connection.” Together,
 RTP and RTCP are the backbone for most live voice and video over the internet,
 balancing speed and quality to keep things smooth and responsive.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
QUIC
\series default
\color inherit
 is a transport protocol built on top of UDP and designed to improve the speed and security of internet connections compared to traditional protocols like TCP.
 When a client (like your browser) connects to a server using QUIC,
 it starts with a single handshake that establishes both the connection and the encryption keys,
 thanks to TLS 1.3 being integrated directly into QUIC itself.
 This handshake usually needs just one round trip,
 which means less waiting time before any real data starts to flow.QUIC uses unique connection IDs that stay the same even if your IP address changes,
 so you can move between networks (for example,
 switching from Wi-Fi to 4G) without losing your session.
 Inside one QUIC connection,
 you can have multiple independent streams of data,
 so if a packet is lost on one stream,
 it doesn’t hold up the others—
unlike TCP,
 where all streams can get blocked if anything goes missing (so-called head-of-line blocking).
 Each QUIC packet carries its own sequence number,
 and the protocol itself handles retransmissions and flow control for each stream separately.Another important detail is that QUIC encrypts not only the application data but also most of its own headers,
 making it harder to track or interfere with connections.
 All QUIC packets are sent over UDP,
 so they’re less likely to get stuck behind firewalls that throttle or filter TCP traffic.
 Because everything (from connection setup to encryption and retransmissions) happens within QUIC,
 it avoids delays from middleboxes,
 optimizes for speed,
 and adapts quickly to changing network conditions.
 Today,
 QUIC is the backbone of HTTP/3,
 which means modern browsers and major web services use it to make loading pages,
 streaming,
 and online communication much faster and smoother compared to the old web stack.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
WireGuard
\series default
\color inherit
 is a modern VPN protocol designed to be fast,
 simple,
 and highly secure.
 Unlike older VPNs like IPsec or OpenVPN,
 WireGuard is built around a minimal codebase and uses cutting-edge cryptography by default,
 such as Curve25519 for key exchange,
 ChaCha20 for encryption,
 and Poly1305 for authentication.
 When you set up a WireGuard tunnel,
 each device generates its own public and private key pair.
 To allow connections,
 you simply exchange public keys with the other side there’s no need for complex certificates or a certificate authority.
 Once configured,
 WireGuard sits at the network layer (Layer 3),
 creating a virtual network interface (like wg0) on your device.
 When you send data,
 it’s automatically encrypted using the peer’s public key,
 wrapped in a UDP packet,
 and sent to the remote endpoint.
 The other side decrypts it using its private key,
 checks the packet’s authenticity,
 and passes the data into its own virtual network.
 Because WireGuard is stateless in the traditional sense no sessions or handshakes after the initial key exchange packets can start flowing almost instantly,
 and connections recover quickly from drops or IP address changes.
 WireGuard uses a “silent by default” design:
 if there’s no traffic,
 it sends nothing,
 making it harder to detect or block.
 It also re-establishes handshakes automatically if network conditions change.
 The protocol is extremely lightweight just a few thousand lines of code which makes it easier to audit and secure compared to legacy VPN solutions.
 In practice,
 this means faster setup,
 lower CPU usage,
 and better performance for most use cases,
 whether you’re building a corporate VPN,
 connecting remote workers,
 or just protecting your data on public Wi-Fi.
 Because of its efficiency and simplicity,
 WireGuard is now built into the Linux kernel and widely available on most platforms.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
A DoH query
\series default
\color inherit
 (DNS over HTTPS query) is just a DNS request sent inside a secure,
 encrypted HTTPS connection instead of being sent as plain text.
 Normally,
 when your device wants to find the IP address for a website like youtube.com,
 it sends a DNS query in clear text to a DNS server.
 Anyone on the network (like your internet provider) can see or even change these plain DNS requests.
 With DoH,
 your device (usually your browser) wraps the DNS query inside an HTTPS request and sends it to a special DoH server,
 just like visiting a secure website.
 Because HTTPS is encrypted,
 nobody in the middle can see which websites you are looking up or interfere with your requests.
 The DoH server replies with the DNS answer,
 also over HTTPS,
 and your device then connects to the real website.
 In short,
 a DoH query is a DNS request hidden inside secure web traffic,
 protecting your privacy and preventing others from snooping on or tampering with the websites you visit.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Round-robin DNS
\series default
\color inherit
 is a simple technique used to distribute traffic across multiple servers by listing several IP addresses for the same domain name in the DNS records.
 When someone tries to visit a website,
 their device asks the DNS server for the IP address of the site.
 With round-robin DNS,
 the server replies with a list of several IP addresses each pointing to a different server that can handle the request.
 Every time a new DNS query comes in,
 the DNS server rotates the order of the IP addresses it returns.
 For example,
 if a domain has three servers,
 the first user might get IP1 first,
 the next user gets IP2 first,
 and so on.
 This way,
 users are spread out more evenly across all available servers,
 balancing the load and making the site more reliable.
 However,
 round-robin DNS is quite basic:
 it doesn’t check if a server is actually working before giving out its IP address,
 so sometimes users might get directed to a server that’s down.
 Still,
 it’s a popular and easy method to share traffic for big websites,
 gaming servers,
 or any service that needs simple load distribution.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
LDAP,
 or Lightweight Directory Access Protocol,

\series default
\color inherit
 is an application-level protocol that lets you access and manage a directory a special database storing information about users,
 computers,
 groups,
 and other resources in a company.
 It runs over TCP/IP,
 most often on port 389 or 636 for secure connections.
 Instead of each computer or service keeping its own list of users and passwords,
 LDAP provides a central place where everything is stored in a tree-like structure.
 When someone logs in to a computer,
 email,
 VPN,
 or other service,
 that system can check the user’s credentials directly with the LDAP server.
 This means you can set up one account for a person and use it everywhere across the organization,
 making things much simpler to manage.
 On the technical side,
 LDAP servers like Microsoft Active Directory or OpenLDAP let admins organize people and resources into branches and groups that reflect how the real company works.
 You can create rules about who can access what and update user details in one place.
 Computers whether Linux or Windows can be joined to the LDAP directory so users can log in with their company accounts,
 and their permissions or group memberships are automatically pulled from the directory.
 Because LDAP is an open standard,
 it works with a huge range of software and operating systems.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
RADIUS
\series default
\color inherit
 is a network protocol that’s mainly used to handle authentication,
 authorization,
 and accounting for users who connect to network services,
 such as Wi-Fi,
 VPNs,
 or remote access gateways.
 Instead of every router or access point keeping its own list of users and passwords,
 you set up a central RADIUS server where all user credentials and access rules are stored.
 When someone tries to connect,
 say,
 to a company’s Wi-Fi,
 the access point sends the user’s login details to the RADIUS server.
 The server checks the credentials often by comparing the username and password against a central directory like LDAP or Active Directory and then replies with a yes or no,
 and sometimes instructions on what the user is allowed to do.
 Besides authentication,
 RADIUS can enforce policies,
 such as which VLAN a user is assigned to,
 or limit connection times.
 It also tracks accounting data,
 like session duration or the amount of data transferred,
 which is helpful for auditing or billing.
 RADIUS typically uses UDP ports 1812 for authentication and 1813 for accounting.
 The protocol is very common in enterprise networks for controlling access to Wi-Fi,
 VPN,
 dial-up,
 and many other services.
 Its strength is that you get centralized control over who can log in and how,
 so you don’t have to manage passwords or permissions on every device separately.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
Syslog
\series default
\color inherit
 is a standard protocol used for sending system logs and event messages across a network.
 It allows devices like servers,
 routers,
 switches,
 firewalls,
 and printers to report important events to a central log server,
 which makes monitoring and troubleshooting much easier.
 Each message typically includes information like the time,
 the source device,
 the type or severity of the event,
 and the actual log text.
 Syslog servers listen on UDP port 514 by default,
 though it can also use TCP.
 The protocol is simple and widely supported,
 so you can collect logs from all kinds of hardware and software in one place.
 This is essential for system administrators who want to keep track of what’s happening on their network,
 catch problems early,
 and analyze patterns or security incidents.
 Syslog messages can cover anything from user logins and errors to firewall alerts and application logs.
 With a central syslog server,
 you can store,
 search,
 and manage logs from hundreds of devices,
 which helps with auditing and daily operations.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
NTP,
 or Network Time Protocol
\series default
\color inherit
,
 is used to keep the clocks of computers and devices in sync across a network.
 Accurate time is much more important than it seems:
 it’s essential for keeping logs meaningful,
 making sure authentication works,
 coordinating distributed systems,
 and running scheduled tasks at the right moment.
 Without synchronized time,
 it becomes almost impossible to investigate incidents,
 compare events between servers,
 or run security protocols that rely on time stamps.
 Here’s how NTP works in practice.
 Each computer or server has its own internal clock,
 but these clocks naturally drift over time and can fall out of sync with each other.
 To fix this,
 an NTP client runs in the background and regularly contacts one or more NTP servers,
 which provide the precise current time,
 often sourced from atomic clocks or GPS.
 When your device reaches out,
 it sends a request including its own timestamp.
 The server responds with its own timestamps,
 and the client uses this information to calculate network delays and figure out the actual time difference between itself and the server.
 Instead of making sudden jumps,
 the client slowly and smoothly adjusts its own clock to line up with the accurate time.
 NTP works over UDP port 123,
 and usually there’s a hierarchy:
 company devices sync to a local NTP server,
 which in turn syncs with highly accurate external sources.
 This approach keeps all the clocks on your network closely matched.
 Thanks to NTP,
 logs stay meaningful,
 authentication protocols function properly,
 and automated tasks run when they’re supposed to.
 Reliable,
 synchronized time is a basic requirement for any modern IT infrastructure.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SNMP,
 or Simple Network Management Protocol
\series default
\color inherit
,
 is a standard protocol used to monitor and manage network devices like switches,
 routers,
 firewalls,
 printers,
 and servers.
 It lets network administrators collect information about the status and performance of devices,
 check for problems,
 and even make some remote changes if needed.
 Each device that supports SNMP runs a small piece of software called an SNMP agent,
 which keeps track of all sorts of statistics and settings like network traffic,
 CPU usage,
 memory,
 and interface status.
 From the administrator’s side,
 there’s usually an SNMP manager or monitoring system that regularly queries these agents,
 asking for data or getting automatic alerts if something goes wrong.
 The information is organized in a standardized way using something called a MIB (Management Information Base),
 so all the data is structured and easy to work with,
 even if it comes from different vendors.
 SNMP usually uses UDP ports 161 for queries and 162 for alerts,
 known as “traps.” Thanks to SNMP,
 admins can watch the health of their entire network in real time,
 automate responses to problems,
 and keep everything running smoothly from a single dashboard.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SMTP,
 or Simple Mail Transfer Protocol
\series default
\color inherit
,
 is the main protocol used to send email across the internet.
 When you send an email from your client like Outlook,
 Thunderbird,
 or a webmail service your message goes to an SMTP server,
 which then figures out how to deliver it to the recipient’s mail server.
 SMTP handles all the steps involved in relaying and forwarding mail from sender to receiver,
 making sure the message gets where it’s supposed to go.
 SMTP works over TCP,
 usually on port 25,
 465,
 or 587,
 and uses a straightforward text-based conversation between servers to deliver each message.
 It doesn’t deal with fetching or reading email from mailboxes that’s handled by other protocols like IMAP or POP3.
 SMTP is also responsible for handling issues like relaying,
 authentication,
 and spam prevention.
\end_layout

\begin_layout Enumerate

\series bold
\color brown
SMB,
 or Server Message Block
\series default
\color inherit
,
 is a protocol that lets computers share files,
 folders,
 and even printers with each other over a network.
 Imagine you have one computer with a folder full of documents,
 and you want other people in your office to be able to open,
 edit,
 or save files there without copying them back and forth on USB sticks.
 With SMB,
 you can “share” that folder,
 and everyone on the same network can access it right from their own computers,
 as if it was a local folder.
 The same works for printers:
 one printer can be connected to one computer but shared with the whole office so anyone can print.
 SMB is built into Windows and also works on Linux and macOS (for example,
 through Samba).
 It’s the reason you can see “Network Drives” or “Shared Folders” when you browse your company’s network.
 CIFS is just an older version of SMB,
 mostly used on older Windows systems,
 but nowadays people usually mean SMB when they talk about file sharing.
 This is different from remote desktop tools like AnyDesk or TeamViewer.
 With SMB,
 you don’t take control of someone else’s computer or see their screen.
 You’re just working directly with files and folders that live somewhere else on your network,
 without even noticing they’re not physically on your own machine.
 SMB is how companies make it easy for teams to collaborate,
 share documents,
 and use network printers,
 all without needing to physically connect to each device.
\end_layout

\begin_layout Subsection

\color blue
When listing services with netstat command,
 what is the meaning if some network service is LISTENING and binded to the IP address 127.0.0.1?
 What if the service is LISTENING IP address 0.0.0.0?
\end_layout

\begin_layout Standard
If a service is listening on 127.0.0.1,
 it means that service only accepts connections from the same computer (localhost).
 This is commonly used during development,
 when an application is not ready for public use and may have many vulnerabilities,
 so no other device on the network can connect to it only programs running on that machine can use it.
 This approach is typical for services that should not be exposed to the outside world,
 like a local database or a test web server.
 If a service is listening on 0.0.0.0,
 it means the service accepts connections on all network interfaces and IP addresses of the computer.
 This includes both local and remote connections,
 so other devices on the network (and potentially from the internet,
 if there’s no firewall) can reach the service.
 Using 0.0.0.0 is necessary when you want your application or service to be accessible by users or devices across your local network or even from outside,
 such as hosting a website,
 providing a shared resource,
 or running a server that should be reachable by multiple clients.
\end_layout

\begin_layout Subsection

\color blue
Why some applications are using or offer “keepalive” mechanism to maintain established connection (for example SSH connections)?
\end_layout

\begin_layout Standard
Some applications use a “keepalive” mechanism to make sure a network connection stays active and is not dropped by firewalls,
 routers,
 or NAT devices when there is no data being sent for a while.
 For example,
 with SSH connections,
 if you leave a terminal idle,
 many networks or devices will eventually close the connection,
 assuming it’s no longer needed.
 The keepalive mechanism solves this by sending small,
 regular packets over the connection,
 even when there’s no real data being transferred.
 These packets let both sides (and any devices in between) know that the connection is still alive,
 preventing unexpected disconnects due to inactivity.
\end_layout

\begin_layout Standard
To enable keepalive,
 you usually add specific settings in the program’s configuration.
 For SSH,
 you can set ServerAliveInterval and ServerAliveCountMax in your SSH client config file (~/.ssh/config) or ClientAliveInterval and ClientAliveCountMax in the SSH server config (/etc/ssh/sshd_config).
 These options control how often keepalive packets are sent and how many missed responses are allowed before closing the connection.
 If you don’t need keepalive,
 you can simply leave these options unset the connection will work,
 but may disconnect if left idle for too long,
 depending on your network.
\end_layout

\begin_layout Subsection

\color blue
Study available options with command line command “netstat /?” (Windows) or netstat –help (Linux,
 maybe MacOS).
 What different things you can check with netstat command?
\end_layout

\begin_layout Standard
With the netstat command,
 you can inspect many aspects of your system’s network activity.
 Based on the netstat --help output (see screenshot),
 you can:
\end_layout

\begin_layout Itemize
Display all active network connections and their states (connected,
 listening,
 etc.)
\end_layout

\begin_layout Itemize
Show which programs (processes) are using each network socket
\end_layout

\begin_layout Itemize
List all listening server sockets (services waiting for incoming connections)
\end_layout

\begin_layout Itemize
Display the routing table,
 showing how network traffic is directed
\end_layout

\begin_layout Itemize
View detailed statistics for each protocol (like TCP,
 UDP,
 ICMP,
 etc.)
\end_layout

\begin_layout Itemize
Show statistics and status for all network interfaces
\end_layout

\begin_layout Itemize
Check which multicast groups your interfaces have joined
\end_layout

\begin_layout Itemize
Show masqueraded (NAT) connections
\end_layout

\begin_layout Itemize
Display the forwarding information base or routing cache
\end_layout

\begin_layout Itemize
Customize the output to show numeric IPs,
 ports,
 or user names
\end_layout

\begin_layout Itemize
Continuously monitor changes with the -c option
\end_layout

\begin_layout Itemize
The help output also lists available options for working with different socket types (TCP,
 UDP,
 UNIX,
 etc.) and address families (IPv4,
 IPv6,
 etc.),
 so you can filter exactly what you need.
\end_layout

\begin_layout Standard
Below is a screenshot of the netstat --help output on my system:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted16.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Do the 50 ms mystery quiz from https://mysteries.wizardzines.com/.
 What was the cause of extra 50 ms delay?
\end_layout

\begin_layout Standard
The slowness is caused by the recvfrom system call taking a long time to return (about 40ms).
 This means the server is spending most of the time waiting to receive data from the client.
 Probably some problem with the internet connection or maybe I am using some slow protocol.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted17.png
	scale 30

\end_inset


\end_layout

\begin_layout Part*
Week #4
\end_layout

\begin_layout Subsection

\color blue
Use Croc to move file or files between two or more hosts/devices.
 Answer shortly:
\end_layout

\begin_layout Itemize

\color blue
How the Croc works?
\end_layout

\begin_layout Itemize

\color blue
How the Croc moves files if both hosts are not directly visible to each other?
 (for example,
 both are behind NATs or basic firewalls)
\end_layout

\begin_layout Standard
Croc is an open source command-line tool for sending files,
 folders,
 or text between two computers securely and conveniently even if both are behind NAT,
 firewalls,
 or on totally different networks.
 What sets Croc apart is its focus on end-to-end encryption,
 simple peer coordination,
 and its ability to work even in restrictive network conditions without user configuration.
 When you want to send a file with Croc,
 you start by running a command like croc send somefile.zip.
 The Croc client immediately generates a random,
 human-readable code (e.g.,
 bold-wolf-7).
 This code acts as both a rendezvous token (so both parties join the same session) and as the basis for cryptographic key exchange.
 You send this code to your recipient however you want by chat,
 phone,
 or in person.
 Both the sender and receiver clients connect to a public relay server (by default,
 croc.schollz.com:9009).
 This server's job is just to help the two parties find each other and exchange the minimal information needed to establish a direct connection.
 It’s not a storage server,
 and it never sees your files in plain text.
 Once both parties connect to the relay with the same code,
 they try to set up a peer-to-peer connection using a process called UDP hole punching.
 This lets two computers behind NAT routers try to establish direct contact by simultaneously sending UDP packets to each other's public IP and port as seen by the relay.
 If their routers support it (as most home routers do),
 a direct encrypted connection is made.
 If not,
 Croc transparently relays the traffic through the server,
 always keeping your data encrypted.
 Before any file is sent,
 Croc uses a cryptographic protocol called PAKE (specifically,
 SPAKE2) to derive a strong,
 session-specific encryption key from the shared code.
 The actual code is never sent over the network only cryptographic “blobs” that can’t be used to brute-force the key.
 All file data is then encrypted using AES-256-GCM (for confidentiality and authentication) before being sent over the wire,
 whether direct or through the relay.
 Files are chunked into pieces and transferred over QUIC (a modern UDP-based protocol) if possible,
 or TCP as a fallback.
 At the end,
 both parties compare file hashes to ensure integrity.
 In practice,
 this means that as long as you keep your session code secret,
 nobody can read your files not the relay server,
 not an attacker on the network,
 and not anyone who sees your encrypted packets.
 However,
 if someone learns your session code before the transfer,
 they could connect as a receiver and get the file,
 so you should treat the code as a sensitive secret and share it carefully.
 Croc doesn’t require opening ports,
 setting up accounts,
 or configuring firewalls.
 It works cross-platform and provides a real “just works” experience for sending sensitive files securely to anyone,
 anywhere even if they’re both behind restrictive networks.
\end_layout

\begin_layout Standard
Step 1.
 Install Croc on Both Machines:
\end_layout

\begin_layout Standard

\series bold
\color magenta
On Arch Linux (local):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted18.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color magenta
On Gentoo (remote):
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted19.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
Step 2.
 Prepare a test file to be sent on my local machine:
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted20.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
3.
 Sending And generating a secret code:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted21.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
4.
 I'v got some file bro:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted22.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
5.
 It works and I am happy.
 
\end_layout

\begin_layout Subsection

\color blue
Study how NTP protocol operates and analyse this Python NTP client code.
 Also available here as plain text.
\end_layout

\begin_layout Standard

\color blue
This Python script uses direct socket programming to access the NTP server.
 Comment individual socket programming related code lines.
 Also,
 answer these:
\end_layout

\begin_layout Enumerate

\color blue
What is the NTP server (DNS) hostname?
\end_layout

\begin_layout Enumerate

\color blue
What is the destination port number being used?
\end_layout

\begin_layout Enumerate

\color blue
Is this Python script using TCP or UDP?
 How do you know?
\end_layout

\begin_layout Enumerate

\color blue
Try to execute the app with Python
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted23.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
The NTP server sends back a 48-byte reply where the exact moment when the server sent its response is encoded in two fields:
 the 10th and 11th words of the packet (each word is 4 bytes).
 The 10th word contains the number of seconds since January 1,
 1900,
 and the 11th word gives the fractional part of that second as a 32-bit integer.
 To get the precise timestamp,
 the script combines these two values,
 adding the seconds and the fraction (divided by 2 to the power of 32),
 and then adjusts for the epoch difference between NTP and Unix time.
 This is how the script retrieves the accurate current time from the NTP server.
\end_layout

\begin_layout Subsection

\color blue
Do these Python programming assignments with Windows or Linux (or with MacOS if you want and know how)
\end_layout

\begin_layout Standard

\color blue
For example,
 use https://realpython.com/python-sockets/ or similar site(s) for socket programming example codes and create TCP client and TCP server Python scripts
\end_layout

\begin_layout Itemize

\color blue
Establish a TCP connection between your client and server Python scripts (either as localhost traffic or between two separate hosts if you have access to two or more Python running hosts without firewall preventing the traffic)
\end_layout

\begin_layout Itemize

\color blue
Transfer some ASCII text strings between the hosts
\end_layout

\begin_layout Itemize

\color blue
TCP client connects to the server,
 sends some plain text string and then disconnects
\end_layout

\begin_layout Itemize

\color blue
Server prints the text to the console or elsewhere
\end_layout

\begin_layout Itemize

\color blue
Save your source codes and work.
 You need scripts again during the course week #5 (Wireshark protocol analyzer assignments)
\end_layout

\begin_layout Itemize

\color blue
Use netstat or similar command line tools to check the TCP connection status (for example the Python server script LISTENING the selected TCP port)
\end_layout

\begin_layout Standard
1.
 I will use sshfs to be able to work with the file from GUI rather than using vim because I was brn in 1995 and not in 1975 though I like vim but not this time.
 This time I want to finish this exercise faster so I can go and drink some beer.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted24.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
2.
 I create remotely on the remote server using GUI the file 
\begin_inset Quotes eld
\end_inset

nothing_server.py
\begin_inset Quotes erd
\end_inset

 In the attached screenshot Yuo will fing the comments which explain what happens there.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted25.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
3.
 I create a client named 
\begin_inset Quotes eld
\end_inset

nothing_client.py
\begin_inset Quotes erd
\end_inset

 on my local machine in the same style:
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted26.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
4.
 I run the server on the remote host:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted27.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
5.
 I run the client and recieve a message from it on my Gentoo server:
\end_layout

\begin_layout Standard
Server:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted30.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted28.png
	scale 30

\end_inset


\begin_inset Graphics
	filename pasted29.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
6.
 I go to the bar and get some beer because I have a good mood now after all and wish you a good day or night too.
\end_layout

\begin_layout Part*
Week #5
\end_layout

\begin_layout Subsection

\color blue
Define following terms and concepts shortly:
\end_layout

\begin_layout Enumerate

\color blue
What is the difference between encoding and encryption?
\end_layout

\begin_layout Enumerate

\color blue
List few common encryption algorithms or systems
\end_layout

\begin_layout Enumerate

\color blue
List few common encoding systems
\end_layout

\begin_layout Enumerate

\color blue
What are plain text protocols?
 List some
\end_layout

\begin_layout Enumerate

\color blue
Encapsulation (protocol)
\end_layout

\begin_layout Enumerate

\color blue
JSON,
 XML,
 YAML,
 CSV
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate

\color brown
Difference between encoding and encryption
\color inherit
 Encoding means taking some data and converting it into another format that computers or communication systems can handle more easily.
 The goal is not to hide the content,
 but to make sure the data can be transmitted or stored without getting corrupted.
 For example,
 Base64 turns binary data into readable ASCII characters so that it can be sent through text-based channels like email.
 Common text encodings,
 such as UTF-8,
 are also just rules that say how characters are represented as numbers and bytes.
 Anyone who knows the encoding method can turn the data back to its original form,
 no secrets needed.
 Encryption,
 on the other hand,
 is about protecting information.
 It changes readable data (plaintext) into something that looks random (ciphertext).
 To get back the original message,
 you need a secret key.
 Without the key,
 the encrypted data should be useless to an outsider.
 This is how we protect sensitive information like passwords,
 credit card numbers,
 or private messages when sending them across the internet.
 Examples of modern encryption include AES,
 RSA,
 or ChaCha20.
 So the main difference:
 encoding is like translating data into another “alphabet” for compatibility,
 while encryption is locking the data with a key so that only authorized people can unlock and read it.
\end_layout

\begin_layout Enumerate

\color brown
Common encryption algorithms and systems Encryption
\color inherit
 can be split into two main categories:
 symmetric (same key for encryption and decryption) and asymmetric (public key to encrypt,
 private key to decrypt).
\end_layout

\begin_deeper
\begin_layout Itemize
AES (Advanced Encryption Standard) – the most widely used symmetric algorithm today.
 It works in blocks of data (128 bits) and supports different key lengths (128,
 192,
 256).
 Used in Wi-Fi (WPA2/WPA3),
 VPNs,
 TLS,
 disk encryption.
\end_layout

\begin_layout Itemize
ChaCha20-Poly1305 – a modern stream cipher with authentication,
 designed as an alternative to AES.
 It’s fast on mobile devices and often used in TLS (for example in Google Chrome,
 WhatsApp,
 and WireGuard VPN).
\end_layout

\begin_layout Itemize
RSA (Rivest–Shamir–Adleman) – an asymmetric encryption system.
 Based on the difficulty of factoring large numbers.
 Often used for exchanging keys securely (e.g.,
 in TLS handshakes).
\end_layout

\begin_layout Itemize
Elliptic Curve Cryptography (ECC) – family of asymmetric algorithms using properties of elliptic curves.
 Provides same level of security with shorter keys compared to RSA.
 Examples include ECDSA (signatures) and ECDH (key exchange).
\end_layout

\begin_layout Itemize
DES / 3DES (Data Encryption Standard) – older symmetric algorithms.
 DES is insecure today,
 and 3DES is being phased out,
 but they were historically very important.
\end_layout

\end_deeper
\begin_layout Enumerate

\color brown
Encoding systems
\color inherit
 are methods of representing data in another format so that it can be stored,
 transmitted,
 or interpreted correctly.
 Unlike encryption,
 they do not hide meaning anyone can decode the data if they know the rules.
 The most common encoding systems are listed below:
\end_layout

\begin_deeper
\begin_layout Itemize
Base64 – converts binary data (like images or files) into ASCII text.
 Common in email attachments (MIME) and web applications (embedding images or JSON data).
\end_layout

\begin_layout Itemize
URL encoding (percent-encoding) – replaces special characters in URLs with % followed by their ASCII hex code (e.g.,
 space → %20).
 Ensures safe transmission of URLs across the web.
\end_layout

\begin_layout Itemize
UTF-8 (Unicode Transformation Format) – the most common character encoding for text.
 It maps characters (letters,
 symbols,
 emojis) into sequences of bytes so computers can process human languages.
\end_layout

\begin_layout Itemize
ASCII (American Standard Code for Information Interchange) – one of the earliest text encodings.
 Maps English letters,
 numbers,
 and symbols into numbers (e.g.,
 A = 65).
\end_layout

\begin_layout Itemize
Hexadecimal encoding – represents binary data as hexadecimal characters (e.g.,
 01001000 → 48 → H).
 Common in debugging and cryptography.
\end_layout

\end_deeper
\begin_layout Enumerate

\color brown
Plain text protocols 
\color inherit
are network protocols where the communication is sent in human-readable form,
 without encryption.
 This means that if someone captures the traffic with a tool like Wireshark,
 they can directly read the commands,
 messages,
 usernames,
 or even passwords.
 These protocols are easy to implement and debug,
 but they are insecure over the open internet because anyone who intercepts the packets can see the contents.
 Common examples of plain text protocols:
\end_layout

\begin_deeper
\begin_layout Itemize
HTTP (without TLS,
 i.e.
 not HTTPS) – web pages transferred in clear text.
\end_layout

\begin_layout Itemize
FTP (File Transfer Protocol) – transfers files,
 but credentials and data are visible.
\end_layout

\begin_layout Itemize
Telnet – remote terminal access,
 replaced by SSH for security.
\end_layout

\begin_layout Itemize
SMTP,
 POP3,
 IMAP (when used without TLS/SSL) – email protocols that expose message contents and logins.
\end_layout

\begin_layout Itemize
DNS (traditional DNS queries are plain text over UDP/TCP port 53).
\end_layout

\end_deeper
\begin_layout Enumerate

\color brown
Encapsulation
\color inherit
 in networking means that data is wrapped in layers of protocol headers and trailers before being transmitted.
 Each layer in the protocol stack adds its own information (like source/destination addresses,
 ports,
 error checking) around the original message,
 so that the next device or layer knows how to handle it.
 For example,
 if you send a message "Hello" over the internet:
\end_layout

\begin_deeper
\begin_layout Itemize
Application layer (e.g.
 HTTP) → builds the HTTP request with headers and body.
\end_layout

\begin_layout Itemize
Transport layer (e.g.
 TCP) → adds source and destination ports,
 sequence numbers,
 checksums.
\end_layout

\begin_layout Itemize
Network layer (IP) → adds source and destination IP addresses.
\end_layout

\begin_layout Itemize
Data link layer (Ethernet) → adds MAC addresses and frame check sequence.
\end_layout

\begin_layout Itemize
Physical layer → finally converts all this into electrical signals or radio waves.
\end_layout

\begin_layout Itemize
At the receiving side,
 each layer decapsulates the data by stripping off its header and passing the rest upward until only the original message remains.
\end_layout

\end_deeper
\begin_layout Enumerate

\color brown
JSON,
 XML,
 YAML,
 CSV
\end_layout

\begin_layout Itemize
JSON (JavaScript Object Notation) A lightweight text format for structured data.
 It uses key–value pairs,
 arrays,
 and nested objects.
 It is very common in web applications and APIs because it is both human-readable and easy for machines to parse.
 Example:
 a curly-bracket structure with name:
 Anna,
 age:
 25,
 skills:
 Python and SQL.
\end_layout

\begin_layout Itemize
XML (Extensible Markup Language) A markup language where data is written inside opening and closing tags.
 It is more verbose than JSON,
 but it supports attributes,
 namespaces,
 and strict validation with schemas.
 XML has been widely used in web services,
 office documents,
 and configuration files.
 Example:
 a person element with age as an attribute,
 and child elements name and skills.
\end_layout

\begin_layout Itemize
YAML (YAML Ain’t Markup Language) A human-friendly format often used for configuration files.
 It relies on indentation instead of brackets or tags.
 YAML is easier to read and write than JSON or XML,
 but indentation errors can cause parsing problems.
 It is used in tools like Docker Compose,
 Kubernetes,
 and GitHub Actions.
 Example:
 a person object written with indentation showing name Anna,
 age 25,
 and a list of skills.
\end_layout

\begin_layout Itemize
CSV (Comma-Separated Values) A very simple text format for tabular data.
 Each line represents a row,
 and values are separated by commas (or sometimes semicolons).
 It is compact,
 supported by spreadsheets and databases,
 and often used for data export and import.
 Example:
 a table with columns name,
 age,
 and skills,
 where rows contain Anna 25 Python,
 and John 30 SQL.
\end_layout

\begin_layout Subsection

\color blue
Install Wireshark protocol analyser and inspect your IP traffic (DNS requests,
 web browsing and such) with the Wireshark:
\end_layout

\begin_layout Itemize

\color blue
Analyse the plain text traffic between the TCP socket Python scripts you did during the course week #4.
 Note:
 use localhost network interface when capturing host internal traffic (localhost/127.0.0.1)
\end_layout

\begin_layout Itemize

\color blue
Try to ping 8.8.8.8 from command prompt and capture the traffic.
 What protocols ping was using?
 What is the total header length of your ping request (all used protocol headers combined when ping sends echo request)?
\end_layout

\begin_layout Itemize

\color blue
Capture some web browsing traffic and related DNS requests.
 What are those A (and maybe AAAA requests)?
 Which protocol is used for DNS requests?
 (Note:
 This cannot be done with web browser if your browser uses DNS over HTTPS.
 Most do now.
 Either skip this task or disable DoH temporary in the web browser settings)
\end_layout

\begin_layout Standard
I set up a simple Python TCP server and client on my local machine and captured the traffic on the loopback interface (lo).
 In Wireshark I applied the display filter tcp.port == 6666 to isolate this connection.
 The capture shows the three-way handshake (SYN,
 SYN/ACK,
 ACK),
 the data transfer packet,
 and the connection teardown (FIN/ACK).
 By following the TCP stream,
 I could see the payload as human-readable text,
 which demonstrates that plain TCP sockets send application data without any encryption.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted31.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted32.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I captured ICMP Echo Request packets while running a ping to 8.8.8.8 on my wireless interface.
 In Wireshark,
 the packet clearly shows the three protocol layers:
 Ethernet II,
 IPv4 and ICMP.
\end_layout

\begin_layout Standard
Wireshark explicitly displays the IPv4 header length as 20 bytes in the “Header Length” field.
 For Ethernet II and ICMP the exact byte counts are not printed in the GUI,
 because they are fixed and well known:
 Ethernet II always has a 14-byte header (destination MAC,
 source MAC,
 EtherType),
 and ICMP Echo Request always has an 8-byte header (type,
 code,
 checksum,
 identifier,
 sequence number).
\end_layout

\begin_layout Standard
When adding them together we get:
\end_layout

\begin_layout Itemize
Ethernet II:
 14 bytes (not shown,
 but fixed)
\end_layout

\begin_layout Itemize
IPv4:
 20 bytes (explicitly shown in Wireshark)
\end_layout

\begin_layout Itemize
ICMP:
 8 bytes (fixed format)
\end_layout

\begin_layout Standard
This results in a total header length of 42 bytes (336 bits).
 The payload section is also visible in Wireshark as “Data (40 bytes)”,
 which is the repeating byte sequence that the ping program inserts into each request.
 Wireshark also reports “98 bytes on wire”,
 which is larger than 42+40 = 82 bytes,
 because Ethernet frames are padded to the minimum size and include the CRC checksum on the wire.
\end_layout

\begin_layout Standard
This analysis shows both how the protocols encapsulate each other (Ethernet → IPv4 → ICMP) and why Wireshark sometimes shows the exact header length field (IPv4) and sometimes not (Ethernet,
 ICMP,
 since their headers are fixed).
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted33.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I captured web browsing traffic on interface wlan0 using Wireshark.
 By applying the filter dns,
 I observed Standard query A (IPv4 address lookups) and Standard query AAAA (IPv6 address lookups).
 The packets were transported using UDP protocol on port 53.
 This confirms that the system resolver used classic DNS requests to translate domain names (e.g.,
 push.services.mozilla.com) into IP addresses.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted35.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Download this zipper pcap traffic file and inspect it with Wireshark.
 The IP traffic sample is about IoT device sending base64 encoded and JSON formatted data to a server.
 Answer these questions:
\end_layout

\begin_layout Itemize

\color blue
What is the total size of captured frame in bits?
\end_layout

\begin_layout Itemize

\color blue
What is the payload length (data) in bytes?
\end_layout

\begin_layout Itemize

\color blue
What is the source IP address of device sending the traffic?
\end_layout

\begin_layout Itemize

\color blue
What is the destination IP address receiving the traffic?
\end_layout

\begin_layout Itemize

\color blue
What is the IP family procotol delivering the data?
\end_layout

\begin_layout Itemize

\color blue
What is the source port?
\end_layout

\begin_layout Itemize

\color blue
What is the destination port?
\end_layout

\begin_layout Itemize

\color blue
Extract the payload as printable text (use right mouse button and copy as printable text for the data part only).
 Use any base64 decoder to convert the data to a plain text JSON message.
 What is the content of JSON formatted data?
\end_layout

\begin_layout Itemize

\color blue
Hint:
 If you struggle with this task,
 you can get the UDP payload if you select the UDP datagram with right mouse button in the Wireshark packet view,
 and use “Follow”.
 It gives you the UDP packet data payload as ASCII text you can copy-paste from the Wireshark popup window to any common base64 decoder
\end_layout

\begin_layout Standard
I opened the provided IoT traffic capture file in Wireshark and inspected the single UDP packet.
\end_layout

\begin_layout Itemize
The total size of the captured frame was 1536 bits (192 bytes on wire).
\end_layout

\begin_layout Itemize
The payload length (data) was 150 bytes.
\end_layout

\begin_layout Itemize
The source IP address of the IoT device was 194.163.171.214.
\end_layout

\begin_layout Itemize
The destination IP address receiving the traffic was 193.167.100.28.
\end_layout

\begin_layout Itemize
The IP family protocol delivering the data was IPv4.
\end_layout

\begin_layout Itemize
The source port was 49240.
\end_layout

\begin_layout Itemize
The destination port was 8080.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted36.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I then extracted the UDP payload as printable text in Wireshark.
 The data was base64 encoded.
 When I decoded it the first time,
 the output was still another base64 string.
 Running a second decode revealed the final JSON message.
\end_layout

\begin_layout Standard
I used the following Linux commands:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted37.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
This confirmed that the IoT device was sending sensor/button data in JSON format over UDP,
 but encoded twice with base64.
\end_layout

\begin_layout Subsection

\color blue
Download this zipper pcap traffic file and inspect it with Wireshark.
 Traffic is simple MySQL session example from Wireshark Wiki.
 Answer these questions:
\end_layout

\begin_layout Itemize

\color blue
What is the destination IP address receiving the traffic?
\end_layout

\begin_layout Itemize

\color blue
What is the destination TCP port?
\end_layout

\begin_layout Itemize

\color blue
Use Wireshark's follow TCP stream feature (right mouse button) and inspect what are the two database rows (animals) and related values which were inserted to the foo table's animal and name columns?
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
I opened the MySQL capture file in Wireshark.
 Inspecting the IP header showed that the destination IP was 192.168.0.254.
 The destination TCP port was 3306,
 which is the default MySQL port.
\end_layout

\begin_layout Standard
By using Wireshark’s Follow → TCP Stream feature,
 I could see the SQL commands in plain text.
 The captured session contained two INSERT statements into the foo table:
\end_layout

\begin_layout Itemize
animal = "dog",
 name = "Goofy"
\end_layout

\begin_layout Itemize
animal = "cat",
 name = "Garfield"
\end_layout

\begin_layout Standard
This demonstrates that unencrypted database traffic exposes sensitive SQL queries and data directly on the network.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted38.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted39.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Download this zipped pcap traffic file and inspect it with Wireshark.
 Traffic has been captured from host 192.168.80.32.
 Answer these questions:
\end_layout

\begin_layout Itemize

\color blue
What is the MAC address of host 192.168.80.32?
\end_layout

\begin_layout Itemize

\color blue
What is the MAC address of host 192.168.80.1?
 Which vendor has build the ethernet chipset of host 192.168.80.1?
 (use Wireshark or IEEE OUI data)
\end_layout

\begin_layout Itemize

\color blue
Which IP address sent ICMP echo requests to this (192.168.80.32) host?
 Also,
 there is a repeating short message inside ICMP datagrams the host sent as ICMP echo request payload.
 What is the repeated message?
\end_layout

\begin_layout Itemize

\color blue
What was the web page the host 192.168.80.32 visited first (full web page address,
 not just the host)?
 What was the web browser or HTTP user agent string used to access that web server?
\end_layout

\begin_layout Itemize

\color blue
What is the hostname in “Host:” field of the HTTP GET request sent by 192.168.80.32?
\end_layout

\begin_layout Itemize

\color blue
What is most likely the default DNS server (the IP address) used by the host 192.168.80.32?
\end_layout

\begin_layout Itemize

\color blue
Use Wireshark’s file/export objects/HTTP feature to extract the ZIP file which was downloaded from the web server 193.167.100.88.
 What is inside the ZIP file?
\end_layout

\begin_layout Itemize

\color blue
Host 192.168.80.32 sent DNS requests to host 9.9.9.9.
 What are the requests?
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted40.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted41.png
	scale 30

\end_inset


\begin_inset Graphics
	filename pasted43.png
	scale 30

\end_inset


\begin_inset Graphics
	filename pasted42.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted44.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
In this task I analyzed the provided pcap file network_capture.pcap with Wireshark.
 The traffic was captured from the host 192.168.80.32.
 First,
 I checked the Ethernet frames and identified the MAC address of this host:
 08:00:27:f1:90:ad.
 Then I looked at the ARP packets and found the MAC address of host 192.168.80.1:
 08:00:27:95:8c:5e.
 According to the IEEE OUI information,
 this belongs to an Oracle VirtualBox virtual network adapter.
 Next,
 I inspected the ICMP packets.
 I observed that echo requests to 192.168.80.32 were sent from 192.168.80.58.
 Inside the ICMP payload there was a repeating short message:
 “Hi there Oamk!”.
 After that I analyzed the HTTP traffic.
 The first request from 192.168.80.32 was a GET to http://www.oamk.fi/~tkorpela/.
 In the HTTP headers I could see that the “Host” field was set to www.oamk.fi.
 The User-Agent string showed that the request was made using Wget/1.20.3 (linux-gnu).
 Looking at the DNS traffic,
 I noticed that the default DNS server used by the host 192.168.80.32 was Google’s public DNS at 8.8.8.8.
 I also filtered traffic going to 9.9.9.9 (Quad9) and found queries for the following domains:
 www.teemukorpela.fi,
 nokia.com (MX record),
 and www.youtube.com (AAAA record).
 Finally,
 I used Wireshark’s “File → Export Objects → HTTP” feature.
 Two objects were listed:
 a small HTML file ~tkorpela and a ZIP archive autumn.zip of about 1 MB.
 I saved the archive and extracted it.
 Inside I found an image file autumn.jpg.
 The picture shows an autumn landscape with two black dogs.
 In summary,
 I was able to find all the answers:
 the MAC addresses of both hosts,
 the vendor of the Ethernet adapter,
 the IP address that sent ICMP echo requests and the repeating payload message,
 the first visited web page and the HTTP User-Agent,
 the “Host” field in the HTTP request,
 the default DNS server,
 the list of DNS queries sent to 9.9.9.9,
 and finally the contents of the ZIP archive captured in the traffic.
\end_layout

\begin_layout Subsection

\color blue
Create a new JSON file with any text editor.
 JSON file should contain data for at least two houses and related IoT sensor data.
 Each house must have few sensors with following information and some random data for each sensor.
\end_layout

\begin_layout Itemize

\color blue
Validate your JSON file with validator:
 jsonlint.com or jsonformatter.curiousconcept.com
\end_layout

\begin_layout Itemize

\color blue
What is GraphQL?
 Also,
 check this traffic and parking API documentation from Oulu (extra task uses this API)
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted45.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
For this assignment I created a JSON file describing IoT sensor data from two houses.
 Each house had several sensors,
 and for every sensor I included an ID number,
 a location description,
 notes,
 a Unix epoch timestamp,
 and three random sensor values.
 After writing the file in a text editor I validated the JSON with an online validator (jsonlint.com).
 The validator confirmed that the syntax was correct and the file was valid JSON.
\end_layout

\begin_layout Standard

\color blue
What is GraphQL?
\end_layout

\begin_layout Standard

\color brown
GraphQL
\color inherit
is an API query language and runtime for requesting exactly the data you need.
 Instead of having many fixed endpoints like in REST,
 GraphQL provides a single endpoint where the client defines the structure of the response.
 This prevents overfetching and underfetching,
 and makes it possible to retrieve related entities with one request.
 The schema defines the available types and fields,
 and the server resolves the query accordingly.
\end_layout

\begin_layout Standard

\color blue
Testing the Oulu traffic API
\end_layout

\begin_layout Standard
I sent the following GraphQL query to the API:
\end_layout

\begin_layout Standard

\family typewriter
\color violet
{
\end_layout

\begin_layout Standard

\family typewriter
\color violet
carParks {
\end_layout

\begin_layout Standard

\family typewriter
\color violet
name
\end_layout

\begin_layout Standard

\family typewriter
\color violet
maxCapacity
\end_layout

\begin_layout Standard

\family typewriter
\color violet
spacesAvailable
\end_layout

\begin_layout Standard

\family typewriter
\color violet
}
\end_layout

\begin_layout Standard

\family typewriter
\color violet
}
\end_layout

\begin_layout Standard
I executed the query with curl:
 
\end_layout

\begin_layout Standard

\family typewriter
\color violet
curl -L -X POST 
\backslash

\end_layout

\begin_layout Standard

\family typewriter
\color violet
-H "Content-Type:
 application/json" 
\backslash

\end_layout

\begin_layout Standard

\family typewriter
\color violet
--data '{ "query":
 "{ carParks { name maxCapacity spacesAvailable } }" }' 
\backslash

\end_layout

\begin_layout Standard

\family typewriter
\color violet
https://api.oulunliikenne.fi/proxy/graphql
\end_layout

\begin_layout Standard
The API responded with live data about car parks in Oulu.
 For example:
\end_layout

\begin_layout Standard

\family typewriter
\color violet
{
\end_layout

\begin_layout Standard

\family typewriter
\color violet
"data":
 {
\end_layout

\begin_layout Standard

\family typewriter
\color violet
"carParks":
 [
\end_layout

\begin_layout Standard

\family typewriter
\color violet
{ "name":
 "Rehaparkki",
 "maxCapacity":
 357,
 "spacesAvailable":
 307 },
\end_layout

\begin_layout Standard

\family typewriter
\color violet
{ "name":
 "Kivisydän",
 "maxCapacity":
 750,
 "spacesAvailable":
 460 },
\end_layout

\begin_layout Standard

\family typewriter
\color violet
{ "name":
 "Technopolis",
 "maxCapacity":
 400,
 "spacesAvailable":
 364 },
\end_layout

\begin_layout Standard

\family typewriter
\color violet
{ "name":
 "Valkea",
 "maxCapacity":
 60,
 "spacesAvailable":
 17 }
\end_layout

\begin_layout Standard

\family typewriter
\color violet
]
\end_layout

\begin_layout Standard

\family typewriter
\color violet
}
\end_layout

\begin_layout Standard

\family typewriter
\color violet
}
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted46.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Install Cmder (or some other toolset where you have Curl or similar tool to make HTTP requests from command line or application.) Use Curl to fetch XML formatted weather data from FMI:
 curl -s -L "https://opendata.fmi.fi/wfs?request=getFeature&storedquery_id=fmi::observations::weather::timevaluepair&place=oulu&timestep=100&parameters=temperature" Inspect and validate the received XML data with www.w3schools.com/xml/xml_validator.asp
\end_layout

\begin_layout Standard
I used the provided FMI (Finnish Meteorological Institute) API.
 With the following curl command,
 I retrieved weather observations for Oulu:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted47.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I copied the XML output and pasted it into the W3Schools XML validator The validation confirmed that the XML data is well-formed and correct.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted48.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsection

\color blue
Decode this base64 encoded message with any tool(s) you prefer:
 SGVsbG8gdGhlcmUgT2FtayBzdHVkZW50ISBBcmUgeW91IGhhdmluZyBmdW4gbm93Pz8/
\end_layout

\begin_layout Standard
I used the Linux command line tool base64 to decode it:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted49.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
and yes I am having alot of fun,
 also because today is Saturday and this hw is going to end soon I will take some beer and watch my gf playing the Witcher 3.
 
\end_layout

\begin_layout Subsection

\color blue
Encode this string:“I love data processing challenges!” with base64 encoding
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted50.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
The flag -n in the echo command is important because,
 by default,
 echo appends a newline character (
\backslash
n) at the end of the string.
 If I did not use -n,
 the newline would also be encoded,
 and the Base64 result would be slightly different.
 Using -n ensures that only the exact text I want is encoded,
 without any extra characters.
\end_layout

\begin_layout Part*
Week #6
\end_layout

\begin_layout Subsection

\color blue
Describe the difference between request-response and publish-subscribe communication models
\end_layout

\begin_layout Standard
Request–response is the traditional way computer communication works on the web.
 In this model a client,
 such as a browser or an application,
 sends a request directly to a server.
 The server then processes the request and returns a response,
 after which the exchange is usually complete.
 The important point is that nothing happens unless the client actively asks for it.
 For example,
 if you want the current weather,
 your phone needs to query the weather service each time.
 This makes request–response predictable and easy to understand because every request has exactly one answer,
 but it also means the client must keep polling repeatedly to see if something has changed.
 Publish–subscribe,
 often used with protocols like MQTT,
 works differently.
 Here the communication is organized around a broker and topics.
 Devices that produce information act as publishers.
 They send their data to the broker under a specific topic name,
 such as “home/kitchen/temperature.” Devices that are interested in this information act as subscribers.
 They register with the broker and say “I want all messages from this topic.” Whenever the publisher sends a new message,
 the broker automatically delivers it to every subscriber.
 The publisher and subscriber do not know each other directly,
 only the topic connects them.
 The practical effect is that publish–subscribe allows instant delivery of updates without repeated polling.
 A temperature sensor can push a new reading as soon as it is measured,
 and a smartphone subscribed to the same topic immediately receives it.
 With request–response the phone would need to ask the sensor again and again,
 even if the value has not changed,
 which wastes bandwidth and battery power.
 Publish–subscribe is therefore especially useful in Internet of Things systems where many devices need to share data in real time with minimal overhead,
 while request–response remains better suited for one-time queries such as fetching a web page or uploading a form.
\end_layout

\begin_layout Subsection

\color blue
Try MQTT websocket demo application
\end_layout

\begin_layout Itemize

\color blue
Subscribe to some existing topic(s) in HiveMQ demo service .
\end_layout

\begin_layout Itemize

\color blue
Publish some messages to the topic(s) you subscribed
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted51.png
	scale 30

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
I used the HiveMQ WebSocket client to test the publish–subscribe model in practice.
 First I connected to the public broker at broker.hivemq.com with port 8884.
 After the connection was established,
 the client showed a green “connected” status.
 I then subscribed to the topic oamkiotcourse/#,
 which means I would receive all messages that are published under that namespace.
 The subscription appeared in the Subscriptions window of the client.
 Next I published my own message.
 I set the topic to oamkiotcourse/test and entered the text “Hello from my client.” As soon as I pressed publish,
 the message appeared in the Messages window,
 because I was already subscribed to the same topic.
 This demonstrated how MQTT delivers data instantly to subscribers without repeated polling.
 By watching other users’ messages and publishing my own,
 I saw the full cycle of connecting,
 subscribing,
 publishing,
 and receiving.
\end_layout

\begin_layout Subsection

\color blue
Explain what are MQTT retained messages
\end_layout

\begin_layout Standard
In MQTT a retained message is a special type of message that the broker keeps stored as the “last known good value” for a topic.
 Normally when a client subscribes to a topic,
 it will only receive new messages that are published after the subscription is active.
 If nothing is published,
 the subscriber receives nothing.
 With retained messages this changes.
 When a publisher sends a message with the retain flag set,
 the broker saves that message as the retained one for that topic.
 The next time any new client subscribes to that topic,
 the broker immediately delivers the retained message,
 even if it was originally published long before.
 This feature is very useful for IoT systems,
 because new devices or applications can instantly learn the current state of the system without waiting for the next update.
 For example,
 a temperature sensor can publish the latest reading as a retained message.
 Even if the sensor only sends a new value once every hour,
 any phone or dashboard that subscribes later will still get the last measurement right away.
 Without retained messages,
 the subscriber would have to wait until the next scheduled update.
 Retained messages are not stored forever in history,
 they only keep the most recent one per topic.
 If a new retained message is published on the same topic,
 it overwrites the old one.
 If a publisher wants to clear the retained message,
 it can send an empty payload with the retain flag set,
 and the broker will remove the stored value.
 This makes retained messages a simple and efficient mechanism to provide “current status” information in publish–subscribe systems.
\end_layout

\begin_layout Subsection

\color blue
List shortly some reasons why MQTT may be better than HTTP for IP-based IoT communication?
 (For example:
 HTTP vs.
 MQTT:
 A tale of two IoT protocols and MQTT Vs.
 HTTP:
 Understanding the Differences)
\end_layout

\begin_layout Standard
MQTT is often considered more suitable than HTTP for IoT communication because it is designed to minimize overhead and deliver data efficiently over unreliable or low-bandwidth networks.
 HTTP uses a request–response pattern where each exchange includes a full set of headers,
 and the client must poll repeatedly to check for updates.
 MQTT,
 on the other hand,
 maintains a lightweight persistent connection and uses the publish–subscribe model so that updates are pushed immediately to subscribers without extra traffic.
 One important difference is the size of the protocol overhead.
 HTTP headers can easily be hundreds of bytes long,
 while MQTT messages can be only a few bytes.
 This means MQTT is more battery-friendly for devices with limited power and more efficient on low-bandwidth links.
 MQTT also has built-in features like Quality of Service levels that ensure messages are delivered even if the connection is unstable,
 and retained messages that let new subscribers get the latest state instantly.
 HTTP does not provide these mechanisms directly.
 Another advantage is that MQTT connections are long-lived and bidirectional,
 so the server can deliver messages to the client as soon as they are available.
 With HTTP,
 clients need to use workarounds like long polling or WebSockets to achieve the same effect.
 For IoT scenarios with thousands of small devices sending sensor data or waiting for commands,
 MQTT’s efficiency,
 reliability features,
 and push-based communication make it a much better choice than classic HTTP request–response.
\end_layout

\begin_layout Subsection

\color blue
What is CoAP?
\end_layout

\begin_layout Standard
CoAP stands for Constrained Application Protocol.
 It is a specialized web transfer protocol designed by the IETF for small,
 resource-limited devices and networks such as those used in the Internet of Things.
 CoAP is built on top of UDP instead of TCP,
 which means it avoids the heavy overhead of connection setup and large headers.
 The protocol is intentionally very lightweight so that tiny devices with little memory,
 low CPU power,
 and limited battery life can still communicate efficiently.
 CoAP follows the same general idea as HTTP:
 it uses a request–response interaction model and supports methods like GET,
 PUT,
 POST,
 and DELETE.
 This makes it easier to integrate with existing web technologies,
 because gateways can translate CoAP requests directly into HTTP when needed.
 However,
 CoAP messages are encoded in a compact binary format rather than text-based headers,
 which saves space.
 A key feature of CoAP is its ability to work well in lossy and low-power networks.
 It includes optional reliability mechanisms built on top of UDP,
 such as confirmable messages that must be acknowledged,
 and non-confirmable messages when speed is more important than reliability.
 CoAP also supports multicast,
 meaning one device can efficiently send a message to many other devices at once,
 which HTTP does not support.
 In addition,
 CoAP includes an “observe” extension that lets clients automatically receive updates from a resource whenever it changes,
 similar to publish–subscribe behavior.
 Because of its efficiency,
 CoAP is widely used in IoT environments where devices need to talk to each other or to gateways without consuming too much energy or network capacity.
 It essentially brings the ideas of the web into the constrained world of sensors and actuators.
\end_layout

\begin_layout Subsection

\color blue
What is 6LoWPAN?
\end_layout

\begin_layout Standard
6LoWPAN stands for IPv6 over Low-Power Wireless Personal Area Networks.
 It is not a completely new protocol,
 but rather an adaptation layer that makes it possible to run IPv6 on top of small wireless networks such as those defined by IEEE 802.15.4.
 The problem it solves is that IPv6 packets are normally quite large and require a minimum transmission unit of 1280 bytes,
 while IEEE 802.15.4 frames can only carry 127 bytes in total.
 Without some kind of adaptation,
 IPv6 would simply not fit.
 6LoWPAN introduces two key mechanisms:
 header compression and fragmentation.
 Header compression removes or shortens many fields of the IPv6 header when they are not necessary,
 reducing the overhead from dozens of bytes to only a few.
 Fragmentation then allows a large IPv6 packet to be split across multiple small 802.15.4 frames and reassembled at the destination.
 With these techniques,
 tiny battery-powered nodes can still participate in an IPv6 network and be addressed directly with global IP addresses.
 The importance of 6LoWPAN is that it makes IoT devices first-class citizens of the Internet.
 Instead of relying on custom protocols or closed networks,
 sensors and actuators using 6LoWPAN can be integrated into standard IP-based systems,
 communicate with the wider Internet through gateways,
 and use the same tools as other networked devices.
 It bridges the gap between the constrained world of wireless sensor networks and the global IPv6 Internet.
\end_layout

\begin_layout Subsection

\color blue
What is IETF ROLL?
\end_layout

\begin_layout Standard
IETF ROLL is the working group in the Internet Engineering Task Force that focuses on routing solutions for low-power and lossy networks.
 The name ROLL comes from “Routing Over Low power and Lossy networks.” These are networks made up of devices such as sensors,
 actuators,
 and small embedded systems that usually operate with very limited energy and have unreliable wireless links.
 Traditional routing protocols like OSPF or BGP are far too heavy for such conditions,
 so the IETF created ROLL to design something lighter and more efficient.
 The main outcome of the ROLL group is the RPL protocol (Routing Protocol for Low-Power and Lossy Networks).
 ROLL defined the requirements and architecture for how routing should work in environments where nodes may go to sleep,
 links may drop packets frequently,
 and memory and CPU resources are extremely constrained.
 Instead of trying to adapt existing Internet routing protocols,
 ROLL worked from the ground up to make something that fits the IoT world.
 In practice,
 ROLL provides the framework and the standardization process,
 while RPL is the protocol that implements the ideas.
 Thanks to ROLL’s work,
 small devices can form multi-hop IPv6 networks where data can flow reliably from many sensors up to a gateway and sometimes back down again,
 without draining the devices’ batteries or requiring constant retransmissions.
\end_layout

\begin_layout Subsection

\color blue
Describe IETF RPL protocol?
\end_layout

\begin_layout Standard
RPL,
 which stands for Routing Protocol for Low-Power and Lossy Networks,
 is the protocol developed by the IETF ROLL group to provide routing in constrained IoT environments.
 It is designed specifically for networks made of small devices with limited battery power and unreliable wireless links,
 where traditional Internet routing protocols would be too heavy or inefficient.
 RPL organizes the network into a structure called a Destination Oriented Directed Acyclic Graph,
 or DODAG.
 In simple terms this is a tree-like graph with one or more root nodes,
 usually a gateway to the wider Internet,
 and many leaf nodes,
 such as sensors.
 Each node has a “rank” that represents its relative position in the graph.
 Data typically flows upward from the leaves toward the root,
 but RPL also supports downward and point-to-point traffic when needed.
 Routing decisions in RPL are based on an Objective Function,
 which can take into account different metrics such as link reliability,
 energy consumption,
 latency,
 or hop count.
 This allows the network to adapt to the constraints of the environment.
 For example,
 in a network where saving energy is the top priority,
 the Objective Function can prefer routes through nodes with higher battery capacity.
 RPL operates with control messages that allow nodes to join the graph,
 update their position,
 and repair the topology when links fail.
 Because the network is “lossy,” meaning packet loss is common,
 RPL is built to be resilient and recover quickly from changes.
 It also supports different modes for downward traffic,
 either storing routing tables in the nodes or letting the root handle all downward routes.
 In practice,
 RPL makes it possible for thousands of small IoT devices to connect in a multi-hop IPv6 network and reach an Internet gateway,
 while still respecting the severe limits of memory,
 processing,
 and energy that these devices face.
 It is therefore one of the core building blocks that allows low-power wireless sensor networks to integrate smoothly with the wider Internet.
\end_layout

\begin_layout Subsection

\color blue
Why classic computer network protocols like TCP/IP,
 data formats such as JSON and XML,
 and security systems like (PKI/HTTPS) won’t usually work at all or are not very optimal to be used in resource limited wireless sensor networks (low power and lossy networks)?
\end_layout

\begin_layout Standard
Classic Internet technologies such as TCP/IP,
 JSON or XML,
 and full PKI-based HTTPS security are not well suited for low-power and lossy networks,
 because they were designed for devices and links that are much stronger than what small IoT nodes can provide.
 Wireless sensor networks often consist of battery-powered nodes with only a few kilobytes of RAM,
 tiny CPUs,
 and radio links that lose packets frequently.
 In this environment every byte and every retransmission matters,
 so the heavy overhead of traditional protocols becomes a serious problem.
 TCP,
 for example,
 provides reliable transport,
 but it does so with mechanisms like three-way handshakes,
 acknowledgment of every segment,
 congestion control,
 and strict ordering of data.
 All of these create extra traffic and force nodes to keep state in memory.
 On a lossy wireless link,
 a single dropped packet can block the whole connection due to head-of-line blocking,
 wasting both energy and bandwidth.
 This is why protocols like CoAP over UDP or RPL-based routing are preferred,
 because they are lighter and allow more flexibility.
 Data formats like JSON and XML are also problematic in constrained networks.
 They are text-based,
 verbose,
 and require significant parsing effort.
 A single sensor value can be encoded in many tens of bytes of text,
 while a binary encoding could send the same information in only a few bytes.
 Parsing XML in particular consumes a lot of memory and CPU cycles,
 which drains batteries and slows down small microcontrollers.
 Security systems like HTTPS with full PKI certificates also create challenges.
 The TLS handshake requires multiple round trips and processing of large cryptographic structures.
 Storing and validating certificate chains consumes memory and CPU power far beyond what a tiny sensor can handle.
 In addition,
 the large headers of HTTPS messages mean more radio airtime,
 which translates directly into higher energy use.
 For this reason IoT environments usually adopt lightweight security approaches such as DTLS or compressed certificate formats designed for constrained devices.
 Overall,
 while TCP/IP,
 JSON/XML,
 and HTTPS are excellent for powerful computers on stable broadband connections,
 they become inefficient and sometimes completely impractical in low-power,
 lossy networks.
 That is why IoT research and standards bodies have developed alternatives like 6LoWPAN for IPv6 compression,
 CoAP for lightweight application messaging,
 CBOR for compact data encoding,
 and simplified security profiles that fit the strict limitations of wireless sensor networks.
\end_layout

\begin_layout Subsection

\color blue
What is the MTU challenge for IPv4 and IPv6 over common wireless low power and lossy wireless connections (Hint:
 Research Zigbee/IEEE 802.15.4 and Bluetooth MTU vs IPv4 or IPv6)?
\end_layout

\begin_layout Standard
The MTU challenge refers to the mismatch between the size of packets expected by Internet protocols like IPv4 and IPv6 and the much smaller frame sizes available in low-power wireless technologies such as Zigbee (IEEE 802.15.4) and Bluetooth.
 MTU stands for Maximum Transmission Unit,
 which is the largest payload that can be sent in a single packet without fragmentation.
 IPv4 networks are expected to handle packets of at least 576 bytes,
 and IPv6 requires every link to support an MTU of at least 1280 bytes.
 This assumption works fine on Ethernet or Wi-Fi,
 where frame sizes are usually 1500 bytes or more.
 However,
 IEEE 802.15.4,
 which is the basis for Zigbee,
 has a maximum physical frame size of only 127 bytes.
 After subtracting the MAC header and other overhead,
 the payload left for higher layers is often less than 100 bytes.
 Bluetooth Low Energy has similar limitations,
 with early versions supporting an ATT payload of only 23 bytes,
 later increased but still far below the 1280 bytes required by IPv6.
 The result is that standard IPv6 packets simply cannot fit into a single low-power wireless frame.
 To make IPv6 usable in such networks,
 an adaptation mechanism is required.
 This is exactly the role of 6LoWPAN:
 it compresses IPv6 headers to just a few bytes when possible,
 and fragments larger packets into multiple small frames that can be reassembled at the receiver.
 Without these techniques,
 it would be impossible to run IPv6 directly over Zigbee or Bluetooth networks.
 This MTU challenge is one of the fundamental reasons why the Internet of Things cannot simply reuse classic Internet protocols unchanged.
 The gap between the large minimum packet sizes of IP and the tiny MTUs of low-power radios forces the use of header compression,
 fragmentation,
 and specialized routing protocols.
 It shows clearly how the physical limits of wireless links shape the design of the whole IoT protocol stack.
\end_layout

\begin_layout Subsection

\color blue
Compare and list few HTTP/1.1,
 HTTP/2 and HTTP/3 differencies and features
\end_layout

\begin_layout Standard
HTTP/1.1,
 HTTP/2,
 and HTTP/3 are three generations of the same web protocol,
 but each one introduces improvements to deal with the weaknesses of the earlier versions.
 HTTP/1.1 is the traditional version that has been used on the web for decades.
 It uses text-based messages and runs over TCP.
 Each request and response is sent one after another.
 Although keep-alive connections were added to avoid opening a new TCP session for every request,
 the protocol still suffers from a limitation known as head-of-line blocking:
 if one request is delayed,
 the others behind it also wait.
 Web browsers tried to solve this by opening multiple TCP connections in parallel,
 but this added overhead and wasted resources.
 HTTP/2 introduced a binary framing layer on top of TCP.
 Instead of sending one request at a time,
 HTTP/2 allows multiplexing:
 many requests and responses can share the same TCP connection.
 Each stream of data is identified and can be prioritized.
 This reduces the need for multiple parallel connections and makes page loading faster.
 HTTP/2 also added header compression (HPACK),
 which cuts down the size of repeated header fields,
 saving bandwidth.
 The drawback is that it still runs over TCP,
 so if a single packet is lost,
 all streams on that connection are blocked until the loss is recovered,
 which means the head-of-line problem is not fully solved.
 HTTP/3 takes a more radical step by abandoning TCP completely and building on top of QUIC,
 a transport protocol that runs over UDP.
 QUIC integrates TLS 1.3 directly,
 so connections are secure by default,
 and the handshake usually takes only one round trip.
 It also supports independent streams within a connection,
 which eliminates head-of-line blocking:
 a lost packet only affects the stream it belongs to,
 not all of them.
 Because QUIC is user-space and based on UDP,
 it can adapt faster to changing network conditions and supports features like connection migration,
 so a session can survive moving from Wi-Fi to mobile data without breaking.
 In short,
 HTTP/1.1 is simple but suffers from inefficiencies with multiple requests,
 HTTP/2 improves throughput with multiplexing and compression but still depends on TCP,
 and HTTP/3 uses QUIC over UDP to provide faster handshakes,
 true parallelism without blocking,
 and better performance on modern networks.
 Together,
 they show the evolution of the web from text-based sequential transfers to secure,
 multiplexed,
 and resilient connections optimized for today’s Internet.
\end_layout

\begin_layout Subsection

\color blue
Use Chrome or other Chromium based browser and it's developer tools (F12),
 and access the course web page tl.oamk.fi/iot/.
 From the developer tools network tab,
 select the main page:
 iot/ and check the response headers.
 Answer:
\end_layout

\begin_layout Itemize

\color blue
What is the connection type?
\end_layout

\begin_layout Itemize

\color blue
What is the server software the web server announced?
\end_layout

\begin_layout Itemize

\color blue
Was any compression / encoding being used?
 (content-encoding)
\end_layout

\begin_layout Itemize

\color blue
Is there X-Xss-Protection set in the response?
\end_layout

\begin_layout Itemize

\color blue
Is there Strict-Transport-Security set in the response?
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted52.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I used Chrome developer tools to check the response headers of the course web page tl.oamk.fi/iot/.
 From the Network tab I selected the main request and looked at the Response Headers.
 The connection type was Keep-Alive.
 The server software announced was Apache.
 Compression was enabled with Content-Encoding:
 gzip.
 There was an X-XSS-Protection header set to 1;
 mode=block.
 There was also a Strict-Transport-Security header with a long max-age value,
 which means the site enforces HTTPS for future connections.
\end_layout

\begin_layout Subsection

\color blue
What is Head-of-Line blocking challenge/problem?
\end_layout

\begin_layout Standard
Head-of-Line (HOL) blocking is a performance problem that happens when multiple data streams are sharing the same transport connection and the loss or delay of one packet prevents the others from being delivered,
 even though they are independent.
 The name comes from the idea of a queue:
 the first packet in line is stuck,
 so all the packets behind it are blocked as well.
 In classic HTTP/1.1 this effect was very visible.
 Requests were sent one after another over a single TCP connection.
 If one response was slow,
 every request behind it had to wait,
 even if the server had already generated the other responses.
 Browsers tried to work around this by opening many parallel TCP connections,
 but that caused other inefficiencies.
 HTTP/2 improved things by allowing multiplexing,
 so multiple streams could share one TCP connection.
 However,
 because TCP enforces strict in-order delivery,
 a single lost packet blocks all streams until it is retransmitted.
 This means HOL blocking still exists at the transport layer:
 even if only one small packet was lost,
 the receiver cannot deliver any subsequent data until the missing packet arrives.
 The solution came with QUIC and HTTP/3.
 QUIC uses UDP and builds its own mechanisms for reliability and congestion control.
 Each stream in QUIC is independent,
 so the loss of a packet on one stream does not stop progress on other streams.
 This eliminates Head-of-Line blocking at the transport level and makes web traffic more responsive,
 especially on mobile or wireless networks where packet loss is common.
 In short,
 Head-of-Line blocking is the problem where one delayed or lost packet blocks everything else behind it,
 and modern protocols like QUIC are designed to remove this bottleneck.
\end_layout

\begin_layout Subsection

\color blue
What is reverse proxy.
 List some advantages and features
\end_layout

\begin_layout Standard
A reverse proxy is a server that sits between clients on the Internet and the actual backend servers that provide the content or services.
 From the client’s perspective it looks like it is connecting directly to the target website,
 but in reality the traffic goes through the reverse proxy first.
 The proxy then forwards the request to one of the backend servers,
 receives the response,
 and sends it back to the client.
 Because of this,
 the backend servers are hidden and protected behind the reverse proxy,
 and the proxy becomes the single visible point of entry.
 One important feature of a reverse proxy is load balancing.
 Instead of sending all client traffic to a single server,
 the proxy can distribute the requests across multiple backend servers.
 This improves scalability,
 makes better use of resources,
 and avoids overloading one machine while others sit idle.
 Another advantage is security.
 Since the reverse proxy is the only system exposed to the Internet,
 it can filter malicious requests,
 enforce TLS encryption,
 or hide details about the backend infrastructure.
 Attackers cannot directly see or access the real servers.
 Caching is another common use.
 A reverse proxy can store frequently requested resources,
 such as images or scripts,
 and serve them directly without contacting the backend.
 This reduces latency for clients and lowers the load on backend servers.
 Reverse proxies also enable central management of features like compression,
 logging,
 authentication,
 and access control.
 Instead of configuring each backend server separately,
 the proxy can handle these functions in one place.
 In practice,
 reverse proxies like Nginx,
 HAProxy,
 or Apache mod_proxy are widely used in web systems.
 They make services faster,
 safer,
 and more scalable by combining load balancing,
 caching,
 encryption,
 and protection in a single gateway layer
\end_layout

\begin_layout Subsection

\color blue
What is Web application firewall (WAF).
 List some advantages and features
\end_layout

\begin_layout Standard
A Web Application Firewall,
 or WAF,
 is a special type of firewall that protects web applications by monitoring,
 filtering,
 and blocking harmful HTTP or HTTPS traffic.
 Unlike a traditional firewall,
 which focuses on network ports and IP addresses,
 a WAF works at the application layer and understands the structure of web requests.
 Its job is to recognize and stop attacks that target web applications,
 such as SQL injection,
 cross-site scripting (XSS),
 or attempts to exploit vulnerabilities in forms and URLs.
 One important feature of a WAF is its ability to inspect the content of requests and responses in real time.
 For example,
 if a request contains suspicious code that looks like an SQL injection attempt,
 the WAF can block it before it reaches the server.
 This adds an extra layer of defense,
 even if the application itself still has a bug.
 A WAF also helps enforce security policies.
 Administrators can define rules such as limiting the size of requests,
 blocking requests from certain countries or IP ranges,
 or requiring stricter validation of cookies and headers.
 Some WAFs use signature-based detection (similar to antivirus) while others apply behavior analysis and machine learning to detect new attack patterns.
 Advantages of a WAF include increased protection against common web vulnerabilities,
 reduced risk of data breaches,
 and compliance with regulations that require web application security.
 A WAF can also provide logging and monitoring,
 giving visibility into suspicious activities and attempted attacks.
 Many cloud providers and content delivery networks include WAF functionality as a managed service,
 making it easier to deploy without additional hardware.
\end_layout

\begin_layout Subsection

\color blue
What are Websockets?
\end_layout

\begin_layout Standard
WebSockets are a communication protocol that provides a persistent,
 bidirectional connection between a client and a server over a single TCP (or QUIC) channel.
 Unlike the traditional request–response model of HTTP,
 where the client always has to ask and the server only answers,
 WebSockets allow both sides to send data at any time once the connection is established.
 The handshake to start a WebSocket connection begins with a normal HTTP request,
 but then it is upgraded to a WebSocket session.
 After that point,
 the same connection stays open,
 and there is no need to reestablish it for every message.
 This reduces overhead and makes the communication much faster,
 especially when there is a continuous flow of small updates.
 The main advantage is real-time communication.
 WebSockets are widely used in applications such as live chat systems,
 online gaming,
 collaborative editing tools,
 dashboards that show stock prices or IoT sensor readings,
 and anywhere updates need to appear immediately without polling.
 Another benefit is efficiency.
 Instead of sending full HTTP headers for every message,
 WebSockets use a lightweight frame format,
 which saves bandwidth and reduces latency.
 Both text and binary data can be sent,
 making it flexible for different use cases.
\end_layout

\begin_layout Subsection

\color blue
What is HTTP long polling?
\end_layout

\begin_layout Standard
HTTP long polling is a technique used to simulate real-time communication over the traditional request–response model of HTTP.
 In normal HTTP,
 the client sends a request and the server immediately sends back a response,
 then the connection closes.
 If the client wants new data,
 it has to send another request.
 This creates delays and wastes bandwidth,
 because the client keeps asking even when there is nothing new.
 With long polling,
 the client still sends an HTTP request,
 but the server does not respond right away.
 Instead,
 it keeps the connection open until there is new data available or a timeout occurs.
 As soon as something happens,
 the server replies with the data.
 The client then immediately sends another request,
 and the process repeats.
 From the user’s perspective it feels like updates are pushed from the server,
 even though technically the client is always the one asking.
 Long polling was widely used before WebSockets became standard.
 For example,
 early chat applications and live notification systems often relied on long polling to deliver near real-time updates.
 The main drawback is inefficiency:
 every new message still requires a full HTTP request and response,
 which includes large headers,
 and many open connections can overload the server.
 It also introduces latency when the connection times out and has to be reestablished.
\end_layout

\begin_layout Subsection

\color blue
Use this tool to check few websites whether the server supports HTTP/2:
 tools.keycdn.com/http2-test.
 Two examples:
 www.kaleva.fi and www.oulu.fi
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted53.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pasted54.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
I used the KeyCDN HTTP/2 Test tool to check whether Finnish websites support HTTP/2.
 When I tested www.kaleva.fi he result showed that the site supports HTTP/2.
 However,
 when I tested www.oulu.fi the tool reported that HTTP/2 protocol is not supported.
 These results show that even large and well-known websites may or may not adopt newer web protocols,
 and tools like this make it easy to verify.
\end_layout

\begin_layout Subsection

\color blue
Study Google Firebase documentation and advertisements.
 Think and list examples how to use Firebase ecosystem with Android application(s) or with some IoT other system?
\end_layout

\begin_layout Standard
Firebase is a collection of managed building blocks that covers sign-in,
 realtime databases,
 storage,
 push messaging,
 A/B testing,
 crash reporting,
 and backend logic with Cloud Functions.
 In a normal Android app I would start with Firebase Authentication so users can sign in with email,
 phone,
 Google,
 or Apple without building my own auth server.
 The same identity is then enforced by Firebase Security Rules,
 so the app can read and write only the user’s own data.
 For app data I would pick Cloud Firestore because it synchronizes in real time and has an offline cache on Android,
 which means the UI stays responsive even when the phone loses the network and later resynchronizes automatically.
 If I need millisecond-level live updates such as chat typing indicators,
 I could also use the Realtime Database;
 for larger media like profile photos or logs I would keep files in Cloud Storage and store only the metadata in Firestore.
 When I need backend logic I would write Cloud Functions that run on events—
saving a profile image can trigger a function that generates thumbnails,
 writing an order can trigger a function that validates payment,
 and a document change can send a push notification through Firebase Cloud Messaging.
 For feature flags and instant tuning I would use Remote Config so I can flip UI behavior or thresholds without shipping a new APK.
 As the app grows I would turn on Crashlytics and Google Analytics for Firebase to see crashes,
 ANRs,
 and retention funnels,
 then use A/B Testing wired to Remote Config to validate UI changes safely.
\end_layout

\begin_layout Standard
In an IoT scenario Firebase is still useful as the human-facing control plane while the devices speak their own efficient protocols.
 A typical pattern is that the edge devices (for example ESP32 sensors) keep publishing telemetry to an MQTT broker,
 while the Android app talks to Firebase.
 Cloud Functions can act as a bridge:
 a small HTTPS function receives MQTT-to-HTTP webhooks from the broker and writes normalized measurements into Firestore;
 from the user’s point of view the Android dashboard just listens to the Firestore collection and shows new readings in real time.
 Commands from the phone can travel in the other direction:
 the app writes a “desired_state” document,
 a Cloud Function triggers on that write and calls the broker’s REST API to publish a command message to the device’s topic.
 If I need to alert the user,
 the function can also send a push via FCM when a threshold is crossed,
 for example “freezer temperature high.” For device configuration I can store per-device settings in Firestore and let Remote Config control global flags like sampling intervals;
 the Android app reads Remote Config directly,
 while devices fetch a compact JSON they understand that was generated by a Cloud Function from the same source of truth.
 For logs and firmware I would keep binary files in Cloud Storage and expose signed URLs with expiration so devices can perform OTA updates safely;
 the Android app can upload diagnostics or photos to the same bucket and the function can verify sizes,
 MIME types,
 or signatures before accepting them.
 Because Firebase enforces identity,
 I can tie each device to an owner account and write Security Rules so that only the owner (and perhaps a support role) can see that device’s data;
 the mobile app benefits from the same rules automatically.
 Finally,
 I would use the Firebase Emulator Suite during development so I can test auth,
 Firestore,
 storage,
 and functions locally without billing,
 then deploy to production with the same configuration.
\end_layout

\begin_layout Subsection

\color blue
Use hivemq.com open MQTT broker service with Python to publish MQTT messages.
 Use this very basic Python MQTT publish example.
 Change the MQTT channel name to something different if the script complaing about the authentication.
 
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
